---
title: "Figures for paper"
date: "2024-05-16"
output: html_document
---

```{r setup, include=FALSE}
# knitr::opts_knit$set(root.dir = "~/Projects/PMO/MeasuringFitnessPerClone/code/3D_Imaging/R/data4paper")
knitr::opts_knit$set(root.dir = "C:/Users/80027908/Desktop/CC_project/PMO_MeasuringFitnessperClone-master/3D_Imaging/R/data4paper")
library(xlsx)
library(dyno)
library(gplots)
library(caret)
library(xtable)
library(tidyverse)
library(matlab)
library(RColorBrewer)
library(flexclust)
library(ggplot2)
library(e1071)
library(slingshot)
library(umap)
library(patchwork)
library(grid)
library(gridExtra)
# devtools::source_url("https://github.com/noemiandor/Utils/master/grpstats.R?raw=TRUE")
OUTLINKED="A06_multiSignals_Linked"
OUTPSEUDOTIME="A08_Pseudotime"
OUTSTATS="A07_LinkedSignals_Stats"
RAWDATA="A01_rawData"

OUTFIGS = "../figs4paper"

xydim = 255
pixelsize_xy = 0.232 # um 
z_interval = 0.29 #  um 
xyz=c("x","y","z")
zslice=35


grpstats <- function(x,g,statscols,q1=0.5){
  allOut=list()
  o=matrix(NA, length(unique(g)),ncol(x) )
  rownames(o)=unique(g); colnames(o)=colnames(x);
  for(col in statscols){
    for(m in unique(g)){
      ii=which(g==m);
      v=NA;
      if(col=='mean'){
        v=apply(x[ii,,drop=F],2,mean,na.rm=T)
      }else if(col=='sum'){
        v=apply(x[ii,,drop=F],2,sum,na.rm=T)
      }else if(col=='var'){
        v=apply(x[ii,,drop=F],2,var)
      }else if(col=='max'){
        v=apply(x[ii,,drop=F],2,max,na.rm=T)
      }else if(col=='min'){
        v=apply(x[ii,,drop=F],2,min,na.rm=T)
      }else if(col=='quantile'){
        v=apply(x[ii,,drop=F],2,quantile,q1,na.rm=T)
      }else if(col=='median'){
        v=apply(x[ii,,drop=F],2,median,na.rm=T)
      }else if(col=='numel+'){##Count elements >0 
        v=apply(x[ii,,drop=F]>0,2,sum,na.rm=T)
      }else if(col=='numel_u'){##Count unique elements 
        v=apply(x[ii,,drop=F],2, function(k) length(unique(k)))
      }else if(col=='fraction+'){##Fraction of elements> 0 out of all finite elements
        v1=apply(!is.na(x[ii,,drop=F]),2,sum,na.rm=T)
        v=apply(x[ii,,drop=F]>0,2,sum,na.rm=T)/v1
      }else if(col=='maxcount'){##Most frequent value
        v1=plyr::count(x[ii])
        v=v1$x[which.max(v1$freq)]
      }else{
        v=get(col)(x[ii,,drop=F])
      }
      o[as.character(m),]=v;
    }
    allOut[[col]]=o;
  }
  return(allOut)
}
```

Define local functions and read image coordinates and features used in multiple Figures:
```{r}
plotPNGorTIF<-function(figname){
  if(fileparts(figname)$ext!=".png"){
    la=tiff::readTIFF(figname)
  }else{
    la=png::readPNG(figname,native = F)
  }
  plot(NA, xlim = c(0, ncol(la)/nrow(la)), ylim = c(0, 1), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "")
  rasterImage(la, 0, 0, ncol(la)/nrow(la),1)
  return(la)
}

# Convert matrix to a data frame with row names, column names, and matrix entry
convert_matrix_to_df <- function(mat, pval) {
  # Create a data frame with all combinations of row and column names
  grid <- expand.grid(Pathway = rownames(mat), "Cell.Feature" = colnames(mat))
  # Add the matrix values as a new column
  grid$r <- as.vector(mat)
  grid$pval <- as.vector(pval)
  return(grid)
}

# Function to truncate strings to a specified length
truncate_string <- function(x, max_length) {
  if (nchar(x) > max_length) {
    return(paste0(substr(x, 1, max_length), "..."))
  } else {
    return(x)
  }
}

getZLIM<- function(coord__){
  tmp = quantile(coord__$z,c(0,1))
  space=tmp[2]-tmp[1]
  zlim=c(tmp[1]-space/2, tmp[2]+space/2)
  return(zlim)
}

readOrganelleCoordinates<-function(signals_per_id, signals, IN){
  coord=NULL;
  for(cell in signals_per_id$x){
    for(s in signals){
      x=paste0(s,"_cell_",cell,"_coordinates.csv")
      a=read.csv(paste0(IN,filesep,x))
      ## pixel to um conversion: @TODO
      a$z=a$z*z_interval
      a$x=a$x*pixelsize_xy
      a$y=a$y*pixelsize_xy
      # id=strsplit(fileparts(x)$name,"_")[[1]]
      a$organelle = a[,ncol(a)] 
      a$intensity = a$signal
      a$signal=s
      # id=id[length(id)-1]
      a$id=cell
      ## add missing columns
      if(!is.null(coord)){
        for(mc in setdiff(colnames(a), colnames(coord))){
          coord[,mc]=NA
        }
        tmp=matrix(NA,nrow(a), ncol(coord))
        colnames(tmp) = colnames(coord)
        coord=rbind(tmp, coord)
        coord[1:nrow(a),colnames(a)] = a
      }else{
        coord=a
      }
      # a[,c("y", "x", "z", "organelle", "id","signal")]
    }
  }
  coord$id=as.numeric(coord$id)
  return(coord)
}

FoFs=c("FoF1_231005_fluorescent.nucleus", "FoF2_231005_fluorescent.nucleus", "FoF3_231005_fluorescent.nucleus", "FoF4_231005_fluorescent.nucleus")

signals=list(nucleus.p="nucleus.p_Cells_Centers.csv",mito.p="mito.p_Cells_Centers.csv",cytoplasm.p="cytoplasm.p_Cells_Centers.csv")
signals_per_id=list()
for(FoF in FoFs){
  OUTLINKED_=paste0(OUTLINKED,filesep,FoF,filesep)
  f=list.files(OUTLINKED_,full.names = T, pattern = ".csv")
  signals_per_id[[FoF]]=plyr::count(sapply(strsplit(f,"_"), function(x) x[length(x)-1]))
}

thedate=strsplit(as.character(Sys.time())," ")[[1]][1]
FoF=FoFs[3]
OUTLINKED_=paste0(OUTLINKED,filesep,FoF,filesep)

load(paste0(OUTPSEUDOTIME, filesep,"pseudotime_2024-05-15.RObj")) ## loads unsupervised pseudotime *model* list
load(paste0(OUTPSEUDOTIME, filesep,"cellCyclePredictionFromImgFeatures_svm_2024-05-15.RObj"))  ## load *svm* details

fucci_raw=read.table( paste0(OUTPSEUDOTIME,filesep,"Fucci_stats.txt"),sep="\t", header = T)
imgStats = read.table(paste0(OUTPSEUDOTIME,filesep,"LabelFree_stats.txt"),sep="\t",header = T)
```



Figure 1: FUCCI to characterize discrete and continuous cell cycle progression in NCI-N87. Setup first:

```{r}
fuccicol=fliplr(rainbow(max(fucci_raw$cellCycle)*1.2)[1:max(fucci_raw$cellCycle)])
names(fuccicol) = c("G1", "G1/S transition","S","G2/M")
fucci_=fucci_raw[fucci_raw$FoF==FoF,]
coord_=readOrganelleCoordinates(signals_per_id[[FoF]], "nucleus.p", OUTLINKED_)
coord_[,c("x","y")] = coord_[,c("x","y")]/pixelsize_xy
coord_ = coord_[coord_$z == zslice*z_interval, ]
coord_$x=-coord_$x
coord_$x=-max(coord_$x)+coord_$x-min(coord_$x)
coord_1 <- coord_
TIF=list.files(paste0(RAWDATA,filesep,FoF), pattern=paste0("_z",zslice), full.names = T)
img=sapply(TIF, function(x) bioimagetools::readTIF(x), simplify = F)
img=sapply(img, function(x) EBImage::rotate(x,-180), simplify = F)
```

Figure 1A: Green and red Fucci channels overlaid. 
```{r}
## Jordan - overlay green [[1]] and red [[3]] -- brighter?

# figname = paste0(OUTFIGS, filesep, "Fig1A_1_",thedate,".png") 
# png(figname)
# bioimagetools::img(img[[1]][,,1]);
# dev.off()
# 
# figname = paste0(OUTFIGS, filesep, "Fig1A_3_",thedate,".png") 
# png(figname)
# bioimagetools::img(img[[3]][,,1]);
# dev.off()

## ImageJ macro for edits
# open("Fig1A_1_2024-05-21.png")
# run("Auto Crop");
# run("Green");
# run("RGB Color");
# open("Fig1A_3_2024-05-21.png")
# run("Auto Crop");
# run("Red");
# run("RGB Color");
# imageCalculator("Add create", "Fig1A_1_2024-05-21.png","Fig1A_3_2024-05-21.png");
# selectImage("Result of Fig1A_1_2024-05-21.png");
# saveAs("Tiff", "Fig1A_overlay.tif");

figname = paste0(OUTFIGS, filesep, "Fig1A_",thedate,".png")
png(figname)
im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"Fig1A_overlay.tif"))
im <- EBImage::resize(im, dim(im)[1]/1)
plot(raster::as.raster(im[,,,1]))
dev.off()

la=plotPNGorTIF(figname)

```



Figure 1B,G: Fucci based descrete cell cycle classification. 
```{r}
palette(c("#FDE725FF", "#35B779FF", "#31688E", "#440154"))

figname = paste0(OUTFIGS, filesep, "Fig1G_",thedate,".png")
png(figname)
plot(fucci_raw$Intensity_IntegratedIntensity_green, fucci_raw$Intensity_IntegratedIntensity_red, col=fucci_raw$cellCycle, pch=20, log="xy")
legend("bottomright", names(fuccicol), fill=1:4)
dev.off()

la=plotPNGorTIF(figname)
fr = plyr::count(names(fuccicol)[fucci_raw$cellCycle])
fr$pct = fr$freq/sum(fr$freq)
print(fr)

## Create two input images for loading into imagej
# cc <-  fucci_ %>% 
#   select(ID, cellCycle)
# coord_ <- left_join(coord_, cc, by = join_by(id == ID))
# 
# pal = colorRampPalette(c("#FDE725FF", "#35B779FF", "#31688E", "#440154"))
# figname = paste0(OUTFIGS, filesep,"overlay.png") 
# png(figname)
# im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"black_blank.tif"))
# im <- EBImage::resize(im, dim(im)[1]/1)
# plot(raster::as.raster(im[,,,1]))
# # points(coord_$x,coord_$y,col=coord_$cellCycle,main=paste(FoF,"fucci"),xaxt='n',yaxt='n', ann=FALSE)
# points(coord_$x,coord_$y,col=scales::alpha(pal(4)[coord_$cellCycle], 0.02),main=paste(FoF,"fucci"),xaxt='n',yaxt='n', ann=FALSE)
# dev.off()
# 
# figname = paste0(OUTFIGS, filesep,"image.png") 
# png(figname)
# bioimagetools::img(img[[2]][,,1]);
# legend("bottomleft", names(fuccicol) , fill=c("#FDE725FF", "#35B779FF", "#31688E", "#440154"))
# dev.off()

## Imagej macro for edits; direct from recorder
# open("C:/Users/80027908/Desktop/CC_project/image.png");
# open("C:/Users/80027908/Desktop/CC_project/overlay.png");
## For threshold, pass all colors and take all but the brightest and darkest intensities
# run("Color Threshold...");
# run("Make Inverse");
# setForegroundColor(0, 0, 0);
## For fill, make sure you fill with black
# run("Fill", "slice");
# selectImage("overlay_2024-05-19.png");
# run("Select None");
## Again fill with black
# //setTool("rectangle");
# makeRectangle(68, 352, 32, 33);
# run("Fill", "slice");
# makeRectangle(77, 111, 4, 18);
# run("Fill", "slice");
# selectImage("image.png");
# run("Add Image...", "image=overlay.png x=0 y=0 opacity=60 zero");
# run("Flatten");
# saveAs("Tiff", "C:/Users/80027908/Desktop/CC_project/Fig1B_contour.tif");

figname = paste0(OUTFIGS, filesep, "Fig1B_",thedate,".png")
png(figname)
im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"Fig1B_contour.tif"))
im <- EBImage::resize(im, dim(im)[1]/1)
plot(raster::as.raster(im[,,,1]))
dev.off()

la=plotPNGorTIF(figname)
```



Figure 1C: Fucci based pseudotime inference reveals cell cycle progression
```{r}
cc <-  fucci_ %>% 
  select(ID, pseudotime)
coord_a <- left_join(coord_, cc, by = join_by(id == ID))
coord_a$order <- findInterval(coord_a$pseudotime, sort(coord_a$pseudotime))

# Create legend image -> manually crop borders before producing the next graph
# pal = colorRampPalette(c("#FDE725FF", "#35B779FF", "#31688EFF", "#440154FF"))
# png(paste0(OUTFIGS, filesep, "legend.png"), width = 250, height = 300)
# plot.new()
# lgd_ = rep(NA, 9)
# lgd_[c(1,5,9)] = c("G1", "S", "G2/M")
# legend(x = 0, y = 1.02,
#        legend = lgd_,
#        fill = pal(9),
#        border = NA,
#        y.intersp = 0.5,
#        bty = "n",
#        cex = 2, text.font = 4)
# dev.off()

pal = colorRampPalette(c("#440154", "#31688E", "#35B779FF", "#FDE725FF"))
figname = paste0(OUTFIGS, filesep,"Fig1C_",thedate,".png")
png(figname)
bioimagetools::img(img[[2]][,,1]);
fucci_[,"pseudotimeCol"]=round(fucci_[,"pseudotime"]*10)
points(coord_a$x,coord_a$y,col=scales::alpha(pal(nrow(coord_a))[coord_a$order], 0.03),xaxt='n',yaxt='n', ann=FALSE,main=paste(FoF,"fucci pseudotime"))
legend <- png::readPNG(paste0(OUTFIGS, filesep, "legend.png"))
rasterImage(legend,0,0,150,200)
dev.off()

la=plotPNGorTIF(figname)
```



Figure 1D: Fucci based pseudotime trajectory in PCA space. 
```{r}
tmp=plot_dimred(model[[paste0("Fucci_",FoF)]],color_cells = "pseudotime", size_cells=0.4,size_milestones=0.4)
tmp
ggsave(paste0(OUTFIGS,filesep,"Fig1D_",thedate,"_Fucci_",FoF,"_pseudotimeTSNE.png"),units="px",width = 0.9*480, height = 480, plot=tmp, dpi=100)
```



Figure 1E + supplementary Fig: Pseudotime is differentially distributed across the four discrete cell cycle classes. 
```{r}
figname = paste0(OUTFIGS, filesep,"Fig1E_",thedate,"_plusSIFig.png")
png( figname, width = 1400, height = 400)
par(mfrow=c(1,4))
ii = sapply(FoFs[c(1,2,4,3)], function(x) grep(x,names(model$Fucci_All$pseudotime),value=T))
sapply(names(ii), function(x) boxplot(model$Fucci_All$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="fucci pseudotime", main=x,cex.lab=1.5,cex.main=1.2, cex.axis=2))
dev.off()
la=plotPNGorTIF(figname)


figname = paste0(OUTFIGS, filesep,"Fig1E_",thedate,".png")
png( figname,width = 280,height = 480)
boxplot(model$Fucci_All$pseudotime[rownames(fucci_raw)]~fucci_raw[,"cellCycle"], xlab="", names=names(fuccicol), ylab="fucci pseudotime", main="All",cex.main=0.6, cex.axis=0.6)
dev.off()
la=plotPNGorTIF(figname)
```




Figure 2: Quantification of nuclei, mitochondria and cytoplasm features at single-cell resolution with label free imaging. Setup first:
```{r}
coord_=readOrganelleCoordinates(signals_per_id[[FoF]], names(signals), OUTLINKED_)
imgStats_=imgStats[imgStats$FoF==FoF,]
doplotcentercoord=c(200, 200)
ii=which(coord_$signal=="nucleus.p")
centroids=grpstats(coord_[ii,c("x","y","z","id")], g = coord_$id[ii],statscols = "median")$median
o2=flexclust::dist2(centroids[,c("x","y")],doplotcentercoord)
alpha=list(cytoplasm.p=0.035,cytoplasm.t=0.01,nucleus.t=1,nucleus.p=0.135,mito.t=0.035,mito.p=0.035)
```



Figure 2A: Predicted nuclei, mitochondria and cytoplasm signals. 
```{r}
## Jordan: Fig 2A: highlight in Figure which cells were used for panel 2B
## Jordan - make brighter - done

## ImageJ macro for all channels image
# open("C:/Users/80027908/Downloads/cytoplasm.p.tif");
# run("Cyan");
# run("RGB Color");
# open("C:/Users/80027908/Downloads/nucleus.p.tif");
# run("Magenta");
# run("RGB Color");
# open("C:/Users/80027908/Downloads/mito.p.tif");
# run("Yellow");
# imageCalculator("Add create stack", "cytoplasm.p.tif","nucleus.p.tif");
# selectImage("Result of cytoplasm.p.tif");
# imageCalculator("Add create stack", "Result of cytoplasm.p.tif","mito.p.tif");
# selectImage("Result of Result of cytoplasm.p.tif");
# saveAs("Tiff", "C:/Users/80027908/Desktop/CC_project/Fig2A_stack.tif");
# run("Slice Keeper", "first=14 last=14 increment=1");
# saveAs("Tiff", "C:/Users/80027908/Desktop/CC_project/Fig2A_slice.tif");

## Create legend image -> manually crop borders before producing the next graph
# pal = colorRampPalette(c("magenta", "white", "yellow", "white", "cyan"))
# png(paste0(OUTFIGS, filesep, "legend_2.png"), width = 300, height = 250)
# plot.new()
# lgd_ = rep(NA, 5)
# lgd_[c(1,3,5)] = c("Nucleus", "Mitochondria", "Cytoplasm")
# legend(x = 0, y = 1.02,
#        legend = lgd_,
#        fill = pal(5),
#        border = NA,
#        y.intersp = 0.5,
#        bty = "n",
#        cex = 2, text.font = 0.2)
# dev.off()

figname = paste0(OUTFIGS, filesep, "Fig2A_",thedate,".png")
png(figname)
im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"Fig2A_slice.tif"))
im <- EBImage::resize(im, dim(im)[1]/1)
plot(raster::as.raster(im[,,,1]))
legend <- png::readPNG(paste0(OUTFIGS, filesep, "legend_2.png"))
rasterImage(legend,0,0,200,100)
dev.off()

la=plotPNGorTIF(figname)

```


Figure 2B: Nuclei, mitochondria and cytoplasm of 10 representative cells from region highlighted in (A). Every data point is color-coded according to its cell membership. 
```{r}
figname=paste0(OUTFIGS, filesep, "Fig2B_2024-05-16_100.png")

if(file.exists(figname)){
  NCELLS=10
  coi=rownames(centroids)[order(o2)[1:NCELLS]]
  coi=setdiff(coi, rownames(imgStats_)[imgStats_$segmentationError])
  coord__=coord_[coord_$id %in% coi,]
  assign("coord__", coord__, .GlobalEnv)
  zlim=getZLIM(coord__)
  rgl::close3d()
  col=rainbow(length(unique(coord__$id)))
  names(col)=as.character(unique(coord__$id))
  for(s in names(signals)){
    X=coord__[coord__$signal==s,]
    if(s=="nucleus.p"){
      rgl::plot3d(X$x, X$y, X$z, pch3d=20, zlim=zlim, size=2, axes=F, xlab="",ylab="", zlab="",col=col[as.character(X$id)],alpha=alpha[[s]]*4, add=T)
    }else{
      rgl::points3d(X$x, X$y, X$z, pch3d=20, col=col[as.character(X$id)],alpha=alpha[[s]]*4, add=T)
    }
  }
  
  rgl::movie3d( movie=fileparts(figname)$name, rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  duration = 3,  dir = OUTFIGS,  type = "gif", clean = TRUE)
}

## For display in rmd only:
la=plotPNGorTIF(figname)

figname=paste0(OUTFIGS, filesep, "Fig2A_slice_marked.tif")
la=plotPNGorTIF(figname)
```



Figure 2C: Nuclei, mitochondria and cytoplasm of 1 representative cell from (B). Every data point is color-coded according to its organelle class. 
```{r}
figname=paste0(OUTFIGS, filesep, "Fig2C_2024-05-16_3.png")

if(!file.exists(figname)){
  coi=rownames(centroids)[order(o2)[7]]
  coi=setdiff(coi, rownames(imgStats_)[imgStats_$segmentationError])
  coord__=coord_[coord_$id %in% coi,]
  zlim=getZLIM(coord__)
  col=rainbow(length(unique(coord__$signal))*1.3)
  names(col)=as.character(unique(coord__$signal))
  rgl::close3d()
  for(s in names(signals)){
    X=coord__[coord__$signal==s,]
    if(s=="nucleus.p"){
      rgl::plot3d(X$x, X$y, X$z, pch3d=20, zlim=zlim, size=2, axes=F, xlab="",ylab="", zlab="",col=col[X$signal],alpha=4*alpha[[s]], add=T)
    }else{
      rgl::points3d(X$x, X$y, X$z, pch3d=20, col=col[X$signal],alpha=alpha[[s]]*4, add=T)
    }
  }
  rgl::legend3d("bottomright",names(signals),fill=col[names(signals)])
  rgl::movie3d( movie=paste0("Fig2C_",thedate), rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  duration = 1,  dir = OUTFIGS,  type = "gif", clean = TRUE)
}

## For display in rmd only:
la=plotPNGorTIF(figname)
```



Figure 2D: Cell features quantified from label free imaging correlate with cell cycle classes as defined by FUCCI. 
```{r}
var_list <- svm$svmFeatures
cycle <- fucci_raw[rownames(imgStats),"cellCycle"]

imgStats_b <- imgStats %>% 
  rownames_to_column(var = "long_ID") %>% 
  cbind(cycle) %>% 
  select(c(long_ID, ID, FoF, cellCycle = cycle, var_list))


list_plots <- vector('list', length(var_list))
for (i in seq_along(list_plots)) {
  list_plots[[i]] <- ggplot(imgStats_b) +
    geom_boxplot(aes(as.character(cellCycle), .data[[var_list[i]]], fill = FoF)) + # , color = as.character(cellCycle))) +
    scale_fill_manual(values = c("FoF1_231005_fluorescent.nucleus" = "yellow", 
                                 "FoF2_231005_fluorescent.nucleus" = "red",
                                 "FoF3_231005_fluorescent.nucleus" = "green",
                                 "FoF4_231005_fluorescent.nucleus" = "blue")) +
    # scale_color_manual(values = c("1" = "#FDE725FF", 
    #                              "2" = "#35B779FF", 
    #                             "3" = "#31688EFF", 
    #                            "4" = "#440154FF")) +
    theme_light() +
    theme(axis.title.x=element_blank(), legend.position = "none") +
    scale_x_discrete(labels=c("1" = "G1", "2" = "G1/S", "3" = "S", "4" = "G2"))
}

e <- ggplot() +
  theme_void()

a <- (list_plots[[1]] + list_plots[[2]] + list_plots[[3]])
b <- (list_plots[[4]] + list_plots[[5]] + list_plots[[6]])
c <- (list_plots[[7]] + list_plots[[8]] + list_plots[[9]])
d <- (list_plots[[10]] + list_plots[[11]] + e)


figname <- paste0(OUTFIGS, filesep, "Fig2D_",thedate,".png")
ggsave(figname,units="px",width = 480, height = 480, plot=list_plots[[1]] + list_plots[[2]], dpi=140)
la=plotPNGorTIF(figname)

a/b/c/d
figname <- paste0(OUTFIGS, filesep, "Fig2D_",thedate,"_plusSIFig.png")
ggsave(figname,units="px",width = 1980, height = 2380, dpi=300)

# figname=paste0(OUTFIGS, filesep, "Fig2D_fill+color.png")
# la=plotPNGorTIF(figname)
```


Figure 3: Characterization of discrete and continuous cell cycle progression in NCI-N87 with label free imaging. 
Figure 3A: Supervised approach to predict discrete cell cycle state from nuclei, mitochondria and cytoplasm features. 
```{r}
## Make diagram in pptx showing:
print(paste("Total cells:",nrow(imgStats),"split into:"), quote = F)
print(paste("Training:",length(unlist(svm$training)),"cells"), quote = F)
print(paste("Testing:",length(unlist(svm$testing)),"cells"), quote = F)
print(paste("SVM trained on",length(svm$svmFeatures),"features and applied on test set"))

# Load the necessary packages
library(DiagrammeR)
library(glue)

# Define the variable
tot_cells = nrow(imgStats)
num_cells_A <- length(unlist(svm$training))
num_cells_B <- length(unlist(svm$testing))
num_features <- length(svm$svmFeatures)


figname = paste0(OUTFIGS, filesep, "Fig3A_",thedate,".png")
# Create the diagram using the grViz function
# Create the graph object using the create_graph function
graph <- grViz(glue("
  digraph diagram {{
    # Define the graph attributes
    graph [layout = dot, rankdir = TB]

    # Define the node attributes
    node [shape = box, style = filled, color = lightgrey, fontname = Helvetica]

    # Define the nodes
    node1 [label = '{tot_cells} Total cells']
    node2 [label = '{num_cells_A} cells']
    node3 [label = '{num_cells_B} cells']
    node4 [label = 'SVM trained on {num_features} cell features']

    # Define the edges (arrows) with labels on the opposite side
    node1 -> node2 [label = 'Training', labeldistance = 2, labelangle = 180]
    node1 -> node3 [label = 'Test', labeldistance = 2, labelangle = 180]
    node2 -> node4
    node4 -> node3 [label = 'application']

    # Subgraph to control the layout
    {{ rank = same; node2; node3 }}
    {{ rank = max; node4 }}
  }}
"))
# Export the graph to a PNG file
# export_graph(graph, file_name = figname, file_type = "png")
graph
# Render the diagram in the RStudio Viewer
# render_graph(graph)
```


Figure 3B: Performance of trained classifier on test set. 
```{r}
confMat = read.xlsx(paste0(OUTPSEUDOTIME, filesep,"cellCyclePrediction_svm_2024-05-15.xlsx"), sheetIndex = 1, row.names=T)
tmp=sapply(c("Class..1","Class..2","Class..3","Class..4"), function(x) as.numeric(confMat[grep(x, rownames(confMat)),"Balanced.Accuracy"])) 

figname=paste0(OUTFIGS, filesep,"Fig3B_",thedate,".png")
png(figname )
boxplot(tmp, names=names(fuccicol), ylab="Balanced.Accuracy")
dev.off()

la=plotPNGorTIF(figname)
```


Figure 3C: Unsupervised approach to predict continuous cell cycle progression from nuclei, mitochondria and cytoplasm features. . 
```{r}
tmp=plot_dimred(model[[FoF]],color_cells = "pseudotime", size_cells=0.4,size_milestones=0.4)
tmp
ggsave(paste0(OUTFIGS,filesep,"Fig3C_",thedate,"_labelFree_",FoF,"_pseudotimeTSNE.png"),units="px",width = 0.9*480, height = 480, plot=tmp, dpi=100)
```


Figure 3D + supplementary Fig: Pseudotime derived from label free imaging features is differentially distributed across the four FUCCI-informed cell cycle classes.  
```{r}
figname=paste0(OUTFIGS, filesep,"Fig3D_",thedate,"_plusSIFig.png")
png(figname, width = 1400, height = 400)
par(mfrow=c(1,4))
ii = sapply(FoFs[c(1,2,4,3)], function(x) grep(x,rownames(fucci_raw),value=T))
# sapply(names(ii), function(x) boxplot(model[[x]]$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main=x,cex.main=0.6))
sapply(names(ii), function(x) boxplot(model$All$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main=x,cex.lab=1.5, cex.axis=2,cex.main=1.2))
dev.off()
la=plotPNGorTIF(figname)


figname=paste0(OUTFIGS, filesep,"Fig3D_",thedate,".png")
png(figname )
par(mfrow=c(1,2))
boxplot(model$All$pseudotime[rownames(fucci_raw)]~fucci_raw[,"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main="All",cex.main=0.6, cex.axis=0.6)
ii=names(model$All$pseudotime)
ii=grep(FoFs[1], ii, value=T, invert = T)
te=cor.test(model$All$pseudotime[ii], model$Fucci_All$pseudotime[ii])
col=rainbow(length(unique(fucci_raw[ii,"FoF"])))
names(col)=unique(fucci_raw[ii,"FoF"])
plot(model$All$pseudotime[ii], model$Fucci_All$pseudotime[ii], main=paste("r=",round(te$estimate,2),"P=",te$p.value), xlab="label free pseudotime",  ylab="fucci pseudotime",  col=col[fucci_raw[ii,"FoF"]])
legend("bottomleft",sapply(strsplit(names(col),"_"),"[[",1),fill=col)
dev.off()
la=plotPNGorTIF(figname)

```


Figure 3E: representative cell across cell cycle: fucci. 
```{r}
# Jordan - fucci pseudotime - done

# Fucci signals
fucci_df <- coord_[grep("nuc", coord_$signal),]
fucci_df$cell <- paste0("cell", fucci_df$id)
rownames(fucci_df) <- NULL

pseud_df <- model$Fucci_All$pseudotime
pseud_df$cell_id <- rownames(pseud_df)
pseud_df <- as.tibble(pseud_df)
pseud_df <- pseud_df %>% 
  pivot_longer(cols = everything()) %>%
  separate(name, into = c("FoF", NA, NA, "cell"), sep = "_") %>% 
  filter(FoF == "FoF3")

fucci_pseud <- left_join(fucci_df, pseud_df, by = join_by(cell == cell))
colnames(fucci_pseud)[colnames(fucci_pseud) == 'value'] <- 'pseudotime'


target_list <- pseud_df %>% 
  filter(!if_any(value, is.na)) %>% 
  filter(abs(value-0.1)==min(abs(value-0.1)) |
           abs(value-0.3)==min(abs(value-0.3)) |
           abs(value-0.5)==min(abs(value-0.5)) |
           abs(value-0.7)==min(abs(value-0.7)) |
           abs(value-0.9)==min(abs(value-0.9)))

target_df <- fucci_pseud %>% 
  filter(cell %in% target_list$cell)

max(target_df$fucci_ch02)

pal <- colorRampPalette(rev(brewer.pal(11, "Spectral")))
sc <- scale_fill_gradientn(colours = pal(10), limits=c(0, 0.61))

for(i in unique(target_df$cell)) {
  p <- target_df %>% 
    filter(cell == i)
  a <- ggplot(p) +
    geom_tile(aes(x, y, fill = fucci_ch00), alpha = 0.4) +
    sc +
    theme_void() +
    theme(legend.position = "none")
  
  xlab <- round(p[1,14], digits = 4)
  b <- ggplot(p) +
    geom_tile(aes(x, y, fill = fucci_ch02), alpha = 0.4) + 
    sc +
    theme_void() +
    theme(legend.position = "none")  +
    theme(axis.title.x = element_text()) +
    labs(x = xlab)
  
  assign(paste0("plot_ch00_", i), a)
  assign(paste0("plot_ch02_", i), b)
}


p <- target_df %>% 
  filter(cell == "cell247")
plot_ch00_cell247 <- ggplot(p) +
  geom_tile(aes(x, y, fill = fucci_ch00), alpha = 0.4) +
  sc +
  theme_void()

xlab <- round(p[1,14], digits = 4)
plot_ch02_cell247 <- ggplot(p) +
  geom_tile(aes(x, y, fill = fucci_ch02), alpha = 0.4) +
  sc + 
  theme_void() +
  theme(axis.title.x = element_text()) +
  labs(x = xlab)

# Pseudotime increasing from left to right 
grid.arrange(
  arrangeGrob(
    textGrob("A", x = 0, y = 1, vjust = 1, hjust = 0, gp = gpar(fontsize = 12, fontface = "bold")),
    plot_ch00_cell151, plot_ch00_cell256, plot_ch00_cell288, plot_ch00_cell84, plot_ch00_cell247, 
    ncol = 6,
    widths = unit(c(0.1, rep(0.2, 4), 0.35), "null")
  ),
  arrangeGrob(
    textGrob("B", x = 0, y = 1, vjust = 1, hjust = 0, gp = gpar(fontsize = 12, fontface = "bold")),
    plot_ch02_cell151, plot_ch02_cell256, plot_ch02_cell288, plot_ch02_cell84, plot_ch02_cell247, 
    ncol = 6,
    widths = unit(c(0.1, rep(0.2, 4), 0.35), "null")
  ),
  nrow = 2
)


## For 3D images
# figname=paste0(OUTFIGS, filesep, "Fig3E_ch00_", thedate, ".png")
# if(!file.exists(figname)){
#   zlim=getZLIM(target_df)
#   rgl::close3d()
#   col=rainbow(length(unique(target_df$fucci_ch00)))
#   names(col)=as.character(unique(target_df$fucci_ch00))
#   rgl::plot3d(target_df$x, target_df$y, target_df$z, 
#               pch3d=20, zlim=zlim, size=2, axes=F, 
#               col=col[as.character(target_df$fucci_ch00)],
#               xlab="",ylab="", zlab="",alpha=1, add=T)
#   rgl::movie3d(movie=fileparts(figname)$name, 
#                rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  
#                duration = 3,  dir = OUTFIGS,  type = "gif", clean = TRUE)
# }

# figname=paste0(OUTFIGS, filesep, "Fig3E_ch02_", thedate, ".png")
# if(!file.exists(figname)){
#   zlim=getZLIM(target_df)
#   rgl::close3d()
#   col=rainbow(length(unique(target_df$fucci_ch02)))
#   names(col)=as.character(unique(target_df$fucci_ch02))
#   rgl::plot3d(target_df$x, target_df$y, target_df$z, 
#               pch3d=20, zlim=zlim, size=2, axes=F, 
#               col=col[as.character(target_df$fucci_ch02)],
#               xlab="",ylab="", zlab="",alpha=1, add=T)
#   rgl::movie3d(movie=fileparts(figname)$name, 
#                rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  
#                duration = 3,  dir = OUTFIGS,  type = "gif", clean = TRUE)
# }

## Check pseudotimes
# zlim=getZLIM(target_df)
# rgl::close3d()
# pal <- colorRampPalette(c("#FDE725FF", "#35B779FF", "#31688E", "#440154"))
# col=pal(length(unique(target_df$pseudotime)))
# names(col)=as.character(unique(target_df$pseudotime))
# rgl::plot3d(target_df$x, target_df$y, target_df$z,
#             pch3d=20, zlim=zlim, size=2, axes=F,
#             col=col[as.character(target_df$pseudotime)],
#             xlab="",ylab="", zlab="",alpha=1, add=T)


```


Figure 3F: representative cell across cell cycle: label free. 
```{r}
# jordan: sample cells from 5+ timepoints (from pseudotime in Fig. 3C) and visualize each as in panel 2C
'%!in%' <- function(x,y)!('%in%'(x,y))

coord_df <- coord_
coord_df$cell <- paste0("cell", coord_df$id)

pseud_df <- model$All$pseudotime
pseud_df$cell_id <- rownames(pseud_df)
pseud_df <- as.tibble(pseud_df)
pseud_df <- pseud_df %>% 
  pivot_longer(cols = everything()) %>%
  separate(name, into = c("FoF", NA, NA, "cell"), sep = "_") %>% 
  filter(FoF == "FoF3")

coord_pseud <- left_join(coord_df, pseud_df, by = join_by(cell == cell))
colnames(coord_pseud)[colnames(coord_pseud) == 'value'] <- 'pseudotime'

target_list_1 <- pseud_df %>% 
  filter(!if_any(value, is.na)) %>% 
  filter(abs(value-0.1)==min(abs(value-0.1)) |
           abs(value-0.3)==min(abs(value-0.3)) |
           abs(value-0.5)==min(abs(value-0.5)) |
           abs(value-0.7)==min(abs(value-0.7)) |
           abs(value-0.9)==min(abs(value-0.9)))

target_list_2 <- pseud_df %>% 
  filter(!if_any(value, is.na)) %>% 
  filter(cell %!in% unique(target_list_1$cell)) %>% 
  filter(abs(value-0.1)==min(abs(value-0.1)) |
           abs(value-0.3)==min(abs(value-0.3)) |
           abs(value-0.5)==min(abs(value-0.5)) |
           abs(value-0.7)==min(abs(value-0.7)) |
           abs(value-0.9)==min(abs(value-0.9)))

target_list_3 <- pseud_df %>% 
  filter(!if_any(value, is.na)) %>% 
  filter(cell %!in% unique(target_list_1$cell) & cell %!in% unique(target_list_2$cell)) %>% 
  filter(abs(value-0.1)==min(abs(value-0.1)) |
           abs(value-0.3)==min(abs(value-0.3)) |
           abs(value-0.5)==min(abs(value-0.5)) |
           abs(value-0.7)==min(abs(value-0.7)) |
           abs(value-0.9)==min(abs(value-0.9)))

target_df <- coord_pseud %>% 
  filter(cell %in% unique(target_list_1$cell) | 
           cell %in% unique(target_list_2$cell) |
           cell %in% unique(target_list_3$cell))

for(i in unique(target_df$cell)) {
  p <- target_df %>% 
    filter(cell == i)
  
  xlab <- round(p[1,14], digits = 4)
  a <- ggplot(p) +
    geom_tile(aes(x, y, fill = signal, alpha = signal)) +
    scale_alpha_manual(values = c("nucleus.p" = 0.01, "mito.p" = 0.05, "cytoplasm.p" = 0.05)) +
    theme_void() +
    theme(legend.position = "none",
          axis.title.x = element_text(),
          panel.background = element_rect(fill = 'black', colour = 'black')) +
    labs(x = xlab) +
    scale_fill_manual(values = c("nucleus.p" = "magenta", "mito.p" = "yellow", "cytoplasm.p" = "cyan"))
  
  assign(paste0("plot_", i), a)
}

p <- target_df %>% 
  filter(cell == "cell199")
xlab <- round(p[1,14], digits = 4)
plot_cell199 <- ggplot(p) +
  geom_tile(aes(x, y, fill = signal, alpha = signal)) +
  scale_alpha_manual(values = c("nucleus.p" = 0.01, "mito.p" = 0.05, "cytoplasm.p" = 0.03)) +
  theme_void() +
  theme(axis.title.x = element_text(),
        panel.background = element_rect(fill = 'black', colour = 'black')) +
  labs(x = xlab) +
  guides(fill = guide_legend(override.aes = list(alpha = 1))) +
  scale_fill_manual(values = c("nucleus.p" = "magenta", "mito.p" = "yellow", "cytoplasm.p" = "cyan"))

p <- target_df %>% 
  filter(cell == "cell216")
xlab <- round(p[1,14], digits = 4)
plot_cell216 <- ggplot(p) +
  geom_tile(aes(x, y, fill = signal, alpha = signal)) +
  scale_alpha_manual(values = c("nucleus.p" = 0.01, "mito.p" = 0.05, "cytoplasm.p" = 0.03)) +
  theme_void() +
  theme(axis.title.x = element_text(),
        panel.background = element_rect(fill = 'black', colour = 'black')) +
  labs(x = xlab) +
  guides(fill = guide_legend(override.aes = list(alpha = 1))) +
  scale_fill_manual(values = c("nucleus.p" = "magenta", "mito.p" = "yellow", "cytoplasm.p" = "cyan"))

p <- target_df %>% 
  filter(cell == "cell80")
xlab <- round(p[1,14], digits = 4)
plot_cell80 <- ggplot(p) +
  geom_tile(aes(x, y, fill = signal, alpha = signal)) +
  scale_alpha_manual(values = c("nucleus.p" = 0.01, "mito.p" = 0.05, "cytoplasm.p" = 0.03)) +
  theme_void() +
  theme(axis.title.x = element_text(),
        panel.background = element_rect(fill = 'black', colour = 'black')) +
  labs(x = xlab) +
  guides(fill = guide_legend(override.aes = list(alpha = 1))) +
  scale_fill_manual(values = c("nucleus.p" = "magenta", "mito.p" = "yellow", "cytoplasm.p" = "cyan"))

# heights = unit(c(0.1, rep(0.05, 4), 0.05), "null")

grid.arrange(
  arrangeGrob(
    textGrob("A", x = 0, y = 1, vjust = 1, hjust = 0, gp = gpar(fontsize = 12, fontface = "bold")),
    plot_cell23, plot_cell160, plot_cell158, plot_cell140, plot_cell199, 
    ncol = 6,
    widths = unit(c(0.1, rep(0.7, 4), 1), "null")
  ),
    arrangeGrob(
    textGrob("B", x = 0, y = 1, vjust = 1, hjust = 0, gp = gpar(fontsize = 12, fontface = "bold")),
    plot_cell63, plot_cell270, plot_cell208, plot_cell301, plot_cell216, 
    ncol = 6,
    widths = unit(c(0.1, rep(0.5, 4), 1), "null")
  ),
    arrangeGrob(
    textGrob("C", x = 0, y = 1, vjust = 1, hjust = 0, gp = gpar(fontsize = 12, fontface = "bold")),
    plot_cell40, plot_cell149, plot_cell21, plot_cell189, plot_cell80, 
    ncol = 6,
    widths = unit(c(0.1, rep(0.5, 4), 1), "null")
  ),
  nrow = 3
)


## For 3D
# figname=paste0(OUTFIGS, filesep, "Fig3F_", thedate, ".png")
# if(!file.exists(figname)) {
#   zlim=getZLIM(target_df)
#   col=rainbow(length(unique(target_df$signal))*1.3)
#   names(col)=as.character(unique(target_df$signal))
#   rgl::close3d()
#   for(s in names(signals)){
#     X=target_df[target_df$signal==s,]
#     if(s=="nucleus.p"){
#       rgl::plot3d(X$x, X$y, X$z, pch3d=20, zlim=zlim, size=2, axes=F, xlab="",ylab="", zlab="",col=col[X$signal],alpha=4*alpha[[s]], add=T)
#     }else{
#       rgl::points3d(X$x, X$y, X$z, pch3d=20, col=col[X$signal],alpha=alpha[[s]]*4, add=T)
#     }
#   }
#   rgl::legend3d("bottomright",unique(target_df$signal),fill=col[unique(target_df$signal)])
#   rgl::movie3d( movie=paste0("Fig3F_",thedate), rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  duration = 1,  dir = OUTFIGS,  type = "gif", clean = TRUE)
# }


## Check pseudotimes
# zlim=getZLIM(target_df)
# rgl::close3d()
# pal <- colorRampPalette(c("#FDE725FF", "#35B779FF", "#31688E", "#440154"))
# col=pal(length(unique(target_df$pseudotime)))
# names(col)=as.character(unique(target_df$pseudotime))
# rgl::plot3d(target_df$x, target_df$y, target_df$z,
#             pch3d=20, zlim=zlim, size=2, axes=F,
#             col=col[as.character(target_df$pseudotime)],
#             xlab="",ylab="", zlab="",alpha=1, add=T)
# la=plotPNGorTIF(figname)

```




Figure 4: Sequencing imaging integration

Figure 4A: Sequencing derived pseudotime of cell cycle progression
```{r}
# cell_ID <- model$Seq$cell_ids
# model_df <- cbind(pseudotime = model$Seq$pseudotime, cell_ID)

tmp=plot_dimred(model$Seq,color_cells = "pseudotime", size_cells=0.4,size_milestones=0.4)
tmp
ggsave(paste0(OUTFIGS,filesep,"Fig4A_",thedate,"_scRNA_pseudotimeTSNE.png"),  units="px",width = 0.9*480, height = 480, plot=tmp, dpi=100)
```


Figure 4B: Co-clustering of sequenced and imaged cells based on pseudotime
```{r}
## co-cluster image and sequencing stats
load(paste0(OUTPSEUDOTIME, filesep,"scRNAdataset_2024-05-15.RObj")); ## loads pq
tmp=as.data.frame(model$All$pseudotime)
colnames(tmp)="pseudotime"
tmp$FoF=imgStats[rownames(tmp),]$FoF
tmp$type="Img"
pq$type="Seq"
stats=rbind(pq[,c("pseudotime","FoF","type")],tmp)
# rownames(stats) = paste0(rownames(stats), "_seq")
ii=which(stats$FoF %in% FoFs)
# rownames(stats)[ii]=gsub("_seq$", "_img",rownames(stats)[ii])
stats=stats[order(stats$pseudotime),]

# dd = as.matrix(dist(as.matrix(stats$pseudotime),method = "manhattan"))
# rownames(dd)<-colnames(dd)<-rownames(stats)
# tr = ape::bionj(dd)
# tr=ape::root(tr, resolve.root=T, outgroup=tr$tip.label[1])
# tr=phytools::force.ultrametric(tr,method = "extend")
# # la=cutree(as.hclust(tr),h = 0.1)
# col = rep("red", length(tr$tip.label))
# col[grep("img",tr$tip.label) ] = "blue"
# figname=paste0(OUTFIGS, filesep,"Fig4B_",thedate,".png") 
# png(figname)
# par(mfrow=c(1,1))
# plot(tr,show.tip.label = T, tip.color = col, cex=0.36)
# legend("topright",c("sequenced cell","imaged cell"),fill=c("red","blue"),cex=1.8)
# dev.off()
# la=plotPNGorTIF(figname)


##for each img cell which seqed cells have this cell as nearest pseudotime neighbor and vice versa?
cl=dbscan::dbscan(as.matrix(stats$pseudotime), eps=0.001,minPts =2)
stats$cluster=cl$cluster
typeRepr=sapply(0:max(stats$cluster), function(x) length(unique(stats$type[stats$cluster==x])))
## Keep only cells that are members of multi-type clusters (Seq + Img):
stats_=stats[typeRepr[stats$cluster+1]==2,]
stats_=stats[stats$cluster>0,]; ## exclude noise
print(paste(length(unique(stats$cluster)),"clusters identified" ))
print(paste(100*length(unique(stats_$cluster))/length(unique(stats$cluster)),"% clusters contain both sequenced and imaged cells" ))


figname=paste0(OUTFIGS, filesep,"Fig4B_",thedate,".png") 
col=rainbow(max(stats_$cluster))
png(figname)
ii=which(stats_$type=="Img")
plot(1:length(ii), stats_$pseudotime[ii], col=col[stats_$cluster[ii]], xlab="cell", ylab="pseudotime", pch=3)
ij=setdiff(1:nrow(stats_),ii)
ij=sort(sample(ij,length(ii)))
points(1:length(ij), stats_$pseudotime[ij], col=col[stats_$cluster[ij]], pch=1)
legend("topleft",c("sequenced cell","imaged cell"),pch=c(1,3),cex=1.2)
dev.off()

la=plotPNGorTIF(figname)
```


Figure 4C: Correlation between gene expression and imaging-derived features
```{r}

## correlation btw gene expression and img features
cc <- pval <- list()
pairs=list()
toExclude=c("FoF","frame","ID","count_nucleus.p","png","type","pseudotime","segmentationError","smv_cell","smv_nucleus.p","smv_mito.p","smv_cytoplasm.p",xyz[1:2]);
for(sFeature in setdiff(colnames(pq),toExclude)){
  cells=sapply(unique(stats_$cluster), function(x) rownames(stats_)[stats_$cluster==x])
  seqCells=sapply(cells, function(x) grep("Clone_",x, value=T))
  imgCells=sapply(cells, function(x) grep("FoF",x, value=T))

  s = sapply(seqCells, function(x) mean(pq[x,sFeature]))
  pairs[[sFeature]] = list()
  for(iFeature in setdiff(colnames(imgStats), toExclude)){
    i = sapply(imgCells, function(x) mean(imgStats[x,iFeature] ))
    x=cor.test(s, i)
    pair=paste(sFeature, iFeature, sep = "+")
    cc[[sFeature]][[iFeature]] =x$estimate
    pval[[sFeature]][[iFeature]] =x$p.value
    pairs[[pair]] = list(s=s,i=i)
  }
}
cc=do.call(rbind,cc)
pval=do.call(rbind,pval)
tmp=rownames(cc)
cc = apply(cc,2,as.numeric)
pval = apply(pval,2,as.numeric)
rownames(cc) <- rownames(pval) <- tmp

## Save as supplementary table
tabname=paste0(OUTFIGS, filesep,"SupplementaryTable1_",thedate,".tex")
cc_ <- convert_matrix_to_df(cc, pval)
cc_$pval = p.adjust(cc_$pval,method = "bonferroni")
ii=which(cc_$pval<=0.05);
print(paste0("Comparing all imaging- and sequencing derived feature pairs across clusters identified ",length(ii)," significantly correlated feature pairs (Pearson r $\\geq$",round(min(abs(cc_$r)[ii]),2),"; Bonferroni-corrected p-value<0.05;"))
cc_=cc_[order(cc_$pval)[1:150],]
cc_$Pathway <- sapply(as.character(cc_$Pathway), truncate_string, 40)
cc_ <- xtable(cc_)
table_code <- print(cc_, type = "latex", include.rownames = FALSE, comment = FALSE, print.results = F)
# Convert the original LaTeX table to the desired format
modified_table <- gsub("\\\\begin\\{table\\}\\[ht\\]", "\\\\begin{longtable}[H]{| p{0.5\\\\textwidth} | p{.3\\\\textwidth} | p{.1\\\\textwidth} | p{.1\\\\textwidth} |}", table_code)
modified_table <- gsub("\\\\end\\{table\\}", "\\\\caption{ Correlation between imaging and sequencing derived feature pairs. Only the top 150 most significant correlations are displayed. P-values are Bonferroni-corrected. }\n \\\\label{ table_imgseq_corr }\n \\\\end{longtable}", modified_table)
modified_table <- gsub("\\\\centering", "", modified_table)
modified_table <- gsub("\\\\begin\\{tabular\\}\\{llrr\\}", "", modified_table)
modified_table <- gsub("\\\\end\\{tabular\\}", "", modified_table)
writeLines(modified_table, tabname)


## sort and plot
poi=unique(unlist(apply(abs(cc),2, function(x) which(x>0.5)), use.names = F))
cc=cc[,!apply(is.na(cc[poi,]),2,all)]
pval=pval[, colnames(cc)]
hm=heatmap.2(t(cc[poi,]),trace="n", margins = c(5,5), cexCol = 0.68)
eval(hm$call)
## jordan: prettify :)
# print(cc[p.adjust(pval, method = "fdr")<0.05])
MINCC=sort(abs(cc), decreasing = T)[9]
ii=which(abs(cc)>MINCC, arr.ind = T)
ii=apply(ii,1, function(x) c(rownames(cc)[x[1]],colnames(cc)[x[2]]))
colnames(ii)=apply(ii,2, paste, collapse="+")

figname=paste0(OUTFIGS, filesep,"Fig4C_",thedate,".png") 
png(figname)
eval(hm$call)
dev.off()

figname=paste0(OUTFIGS, filesep,"Fig4C_",thedate,"_plusSIFig.png") 
png(figname,width = 1200,height = 1200)
par(mfrow=c(3,3))
sapply(colnames(ii), function(x) plot(pairs[[x]]$s, pairs[[x]]$i, main="", cex.main=2, xlab=ii[1,x], ylab=ii[2,x], pch=20,cex=2, cex.lab=2))
dev.off()

la=plotPNGorTIF(figname)
```


Figure 5: Allen model training
```{r}

```


Assemble panels to figure
```{r}
panels = list(Fig1 = c("A", "B", "C", "D", "E","G"), Fig2 = c("A", "B", "C", "D"), Fig3 = c("A", "B", "C", "D"), Fig4 = c("A", "B", "C"), Fig5 = c("A", "B", "C", "D", "E"))
plots = list()
for (fig in names(panels)[1:4]) {
  plots[[fig]] = list()
  for (panel in panels[[fig]]) {
    f = list.files(OUTFIGS, pattern = paste0("^",fig, panel, "_2024"), full.names = TRUE)
    f = grep(".pdf$", f, value = TRUE, invert = TRUE)
    f = grep(".gif$", f, value = TRUE, invert = TRUE)
    f = grep("_plusSI", f, value = TRUE, invert = TRUE)
    dates = sapply(f, function(x) strsplit(fileparts(x)$name, "_")[[1]][2])
    print(paste0(fig, panel))
    f = f[order(as.Date(dates), decreasing = TRUE)[1]]
    # print(f)
    plots[[fig]][[panel]] = plotPNGorTIF(f)
  }
  print(sapply(plots[[fig]], dim))
}
```


Assemble panels to figure
```{r}
# print("SVM Balanced.Accuracy")
# print(confMat[confMat$FoF=="Median","Balanced.Accuracy",drop=F])
# Figure 2D
# figname <- paste0(OUTFIGS, filesep, "Fig2D_",thedate,".png")
# ggsave(figname,units="px",width = 480, height = 480, plot=list_plots[[1]] + list_plots[[2]], dpi=140)
# la=plotPNGorTIF(figname)
# 
# a/b/c/d
# figname <- paste0(OUTFIGS, filesep, "Fig2D_",thedate,"_plusSIFig.png")
# ggsave(figname,units="px",width = 1980, height = 2380, dpi=300)
# Also entire Figure 1E, and 3A and 3D
# Add dpi=100 and replace 0.6*480 with 0.9*480 in all ggsave
# define function convert_matrix_to_df and truncate_string
# git mv _new _
# all that follows:
# Calculate the number of rows and columns for a given number of panels
calculate_layout <- function(num_panels) {
  ncol <- max(2, ceiling(sqrt(num_panels)))  # Ensure at least two columns
  nrow <- ceiling(num_panels / ncol)
  return(c(nrow, ncol))
}
# Assemble panels to figure
captions = list(
  Fig1 = "FUCCI to characterize discrete and continuous cell cycle progression in NCI-N87. A. Green and red Fucci channels overlayed. B,G: Fucci based discrete cell cycle classification. D: Fucci based pseudotime inference reveals cell cycle progression. E: Fucci based pseudotime trajectory in PCA space. Every dot represents a cell. F: Pseudotime is differentially distributed across the four discrete cell cycle classes.",
  Fig2 = "Label-free quantification of nucleus, cytoplasm and mitochndria at single cell resolution. A: Predicted nuclei, mitochondria and cytoplasm signals. B: Nuclei, mitochondria and cytoplasm of 10 representative cells from region highlighted in (A). Every data point is color-coded according to its cell membership. C: Nuclei, mitochondria and cytoplasm of 1 representative cell from (B). Every data point is color-coded according to its organelle class. D: Cell features quantified from label free imaging correlate with cell cycle classes as defined by FUCCI.",
  Fig3 = "Characterization of discrete and continuous cell cycle progression in NCI-N87 with label free imaging. A: Supervised approach to predict discrete cell cycle state from nuclei, mitochondria and cytoplasm features. B: Performance of trained classifier on test set. C: Unsupervised approach to predict continuous cell cycle progression from nuclei, mitochondria and cytoplasm features. D + supplementary Fig: Pseudotime derived from label free imaging features is differentially distributed across the four FUCCI-informed cell cycle classes. E: representative cell across cell cycle: fucci. F: representative cell across cell cycle: label free.",
  Fig4 = "Sequencing imaging integration. A: Sequencing derived pseudotime of cell cycle progression. B: Co-clustering of sequenced and imaged cells based on pseudotime. Color code indicates cluster membership. C: Correlation between pathway activity and imaging-derived features.",
  Fig5 = "Evaluating performance of a CNN to predict the spatial distribution of nuclei and mitochondria. (A-C) Representative paired sets from model training using nucleus (train (N=37) / test (N=5) and mitochondria train (N=24) / test (N=5) models showing bright-field input, target signal and predicted signal (A), with train/validation rolling mean square error loss graphs for nucleus (B) and mitochondria (C). (D) Correlation coefficient of target fluorescence vs predicted fluorescence images paired with correlation coefficient from brightfield for the organelles that were used to train the models."
)
thedate = "2024-05-22"
BORDER = 1
for (fig in names(plots)) {
  # Get the sizes of the plots
  sz = sapply(plots[[fig]], dim)
  layout = calculate_layout(length(plots[[fig]]))
  nrow = layout[1]
  ncol = layout[2]
  
  # Calculate total figure dimensions
  panel_width = max(sz[1,])
  panel_height = max(sz[2,])
  total_width = panel_width * ncol + (ncol - 1) * BORDER
  total_height = panel_height * nrow + (nrow - 1) * BORDER
  
  figname = paste0(OUTFIGS, filesep, fig, "_", thedate, ".png")
  png(figname, width = total_width, height = total_height)
  plot(NA, xlim = c(0, total_width), ylim = c(0, total_height), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "")
  
  panel_index = 1
  for (r in 1:nrow) {
    for (c in 1:ncol) {
      if (panel_index <= length(plots[[fig]])) {
        panel = names(plots[[fig]])[panel_index]
        xleft = (c - 1) * (panel_width + BORDER)
        ybottom = total_height - r * (panel_height + BORDER)
        xright = xleft + panel_width
        ytop = ybottom + panel_height
        rasterImage(plots[[fig]][[panel]], xleft, ybottom, xright, ytop)
        text(xleft + 5, ytop - 5, labels = panel, adj = c(0, 1), cex = 1.5+(fig=="Fig3")*1.5, col = "black", font = 2)
        panel_index = panel_index + 1
      }
    }
  }
  
  dev.off()
  ## Print caption
  print(cat("\\begin{figure}\n",
            '\\includegraphics[width=\\textwidth,height=\\dimexpr \\textheight - 5\\baselineskip\\relax,keepaspectratio]{',gsub("../","",figname, fixed = T),"}\n",
            '\\caption{',captions[[fig]],".}\n",
            '\\label{',fig,"}\n",
            '\\end{figure}\n'))
  
}
```


Supplementary figures
```{r}
thedate = "2024-05-27"
captions = list(
  Fig1E = "Fucci-derived pseudtime is differentially distributed across the four cell cycle phases.",
  Fig4C = "Sequencing- and imaging derived features are correlated.",
  Fig3D = "Pseudtime derived from label-free imaging is differentially distributed across the four cell cycle phases.",
  Fig2D = "Cell features derived from label free imaging correlate with FUCCI derived cell cycle progression."
)
f = list.files(OUTFIGS, pattern = "_plusSI", full.names = TRUE)
f = grep(".pdf$", f, value = TRUE, invert = TRUE)
f = grep(".gif$", f, value = TRUE, invert = TRUE)
figs = sapply(f, function(x) strsplit(fileparts(x)$name, "_")[[1]][1])
for (fig in sort(unique(figs))) {
  f_=grep(fig,f, value = T)
  dates = sapply(f_, function(x) strsplit(fileparts(x)$name, "_")[[1]][2])
  f_ = f_[order(as.Date(dates), decreasing = TRUE)][1]
  # print(f_)
  figname = paste0(OUTFIGS, filesep, "Supplementary",fig, "_", thedate, ".png")
  file.copy(f_, figname, overwrite = T)
  
  ## Print caption
  print(cat("\\begin{figure}[hbt!]\n",
            '\\includegraphics[width=\\textwidth,height=\\dimexpr \\textheight - 5\\baselineskip\\relax,keepaspectratio]{',gsub("../","",figname, fixed = T),"}\n",
            '\\caption{',captions[[fig]],".}\n",
            '\\label{',gsub(fig, paste0("SI",fig),fig),"}\n",
            '\\end{figure}\n'))
}
```