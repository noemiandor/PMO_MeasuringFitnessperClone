---
title: "Figures for paper"
date: "2024-05-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "~/Projects/PMO/MeasuringFitnessPerClone/code/3D_Imaging/R/data4paper")
library(xlsx)
library(dyno)
library(caret)
library(tidyverse)
library(matlab)
library(RColorBrewer)
library(flexclust)
library(ggplot2)
library(e1071)
library(slingshot)
library(umap)
devtools::source_url("https://github.com/noemiandor/Utils/blob/master/grpstats.R?raw=TRUE")
OUTLINKED="A06_multiSignals_Linked"
OUTPSEUDOTIME="A08_Pseudotime"
OUTSTATS="A07_LinkedSignals_Stats"
RAWDATA="A01_rawData"

OUTFIGS = "../figs4paper"

xydim = 255
pixelsize_xy = 0.232 # um 
z_interval = 0.29 #  um 
xyz=c("x","y","z")
zslice=35
```

Define local functions and read image coordinates and features used in multiple Figures:
```{r}
getZLIM<- function(coord__){
  tmp = quantile(coord__$z,c(0,1))
  space=tmp[2]-tmp[1]
  zlim=c(tmp[1]-space/2, tmp[2]+space/2)
  return(zlim)
}

readOrganelleCoordinates<-function(signals_per_id, signals, IN){
  coord=NULL;
  for(cell in signals_per_id$x){
    for(s in signals){
      x=paste0(s,"_cell_",cell,"_coordinates.csv")
      a=read.csv(paste0(IN,filesep,x))
      ## pixel to um conversion: @TODO
      a$z=a$z*z_interval
      a$x=a$x*pixelsize_xy
      a$y=a$y*pixelsize_xy
      # id=strsplit(fileparts(x)$name,"_")[[1]]
      a$organelle = a[,ncol(a)] 
      a$intensity = a$signal
      a$signal=s
      # id=id[length(id)-1]
      a$id=cell
      ## add missing columns
      if(!is.null(coord)){
        for(mc in setdiff(colnames(a), colnames(coord))){
          coord[,mc]=NA
        }
        tmp=matrix(NA,nrow(a), ncol(coord))
        colnames(tmp) = colnames(coord)
        coord=rbind(tmp, coord)
        coord[1:nrow(a),colnames(a)] = a
      }else{
        coord=a
      }
      # a[,c("y", "x", "z", "organelle", "id","signal")]
    }
  }
  coord$id=as.numeric(coord$id)
  return(coord)
}

FoFs=c("FoF1_231005_fluorescent.nucleus", "FoF2_231005_fluorescent.nucleus", "FoF3_231005_fluorescent.nucleus", "FoF4_231005_fluorescent.nucleus")

signals=list(nucleus.p="nucleus.p_Cells_Centers.csv",mito.p="mito.p_Cells_Centers.csv",cytoplasm.p="cytoplasm.p_Cells_Centers.csv")
signals_per_id=list()
for(FoF in FoFs){
  OUTLINKED_=paste0(OUTLINKED,filesep,FoF,filesep)
  f=list.files(OUTLINKED_,full.names = T, pattern = ".csv")
  signals_per_id[[FoF]]=plyr::count(sapply(strsplit(f,"_"), function(x) x[length(x)-1]))
}

thedate=strsplit(as.character(Sys.time())," ")[[1]][1]
FoF=FoFs[3]
OUTLINKED_=paste0(OUTLINKED,filesep,FoF,filesep)

load(paste0(OUTPSEUDOTIME, filesep,"pseudotime_2024-05-15.RObj")) ## loads unsupervised pseudotime *model* list
load(paste0(OUTPSEUDOTIME, filesep,"cellCyclePredictionFromImgFeatures_svm_2024-05-15.RObj"))  ## load *svm* details

fucci_raw=read.table( paste0(OUTPSEUDOTIME,filesep,"Fucci_stats.txt"),sep="\t", header = T)
imgStats = read.table(paste0(OUTPSEUDOTIME,filesep,"LabelFree_stats.txt"),sep="\t",header = T)
```



Figure 1: FUCCI to characterize discrete and continuous cell cycle progression in NCI-N87. Setup first:

```{r}
fuccicol=fliplr(rainbow(max(fucci_raw$cellCycle)*1.2)[1:max(fucci_raw$cellCycle)])
names(fuccicol) = c("G1", "G1/S transition","S","G2/M")
fucci_=fucci_raw[fucci_raw$FoF==FoF,]
coord_=readOrganelleCoordinates(signals_per_id[[FoF]], "nucleus.p", OUTLINKED_)
coord_[,c("x","y")] = coord_[,c("x","y")]/pixelsize_xy
coord_ = coord_[coord_$z == zslice*z_interval, ]
coord_$x=-coord_$x
coord_$x=-max(coord_$x)+coord_$x-min(coord_$x)
TIF=list.files(paste0(RAWDATA,filesep,FoF), pattern=paste0("_z",zslice), full.names = T)
img=sapply(TIF, function(x) bioimagetools::readTIF(x), simplify = F)
img=sapply(img, function(x) EBImage::rotate(x,-180), simplify = F)
```

Figure 1A: Green and red Fucci channels overlayed. 
```{r}
## jordan: these should be in img[[1]] and img[[3]] defined above
```



Figure 1B: Fucci based descrete cell cycle classification. 
```{r}
plot(fucci_raw$Intensity_IntegratedIntensity_green, fucci_raw$Intensity_IntegratedIntensity_red, col=fucci_raw$cellCycle, pch=20, log="xy")
legend("bottomright", names(fuccicol), fill=1:4)


figname = paste0(OUTFIGS, filesep,"Fig1B_",thedate,".png") 
png(figname)
bioimagetools::img(img[[2]][,,1]);
#bioimagetools::img(resize4Ilastik(img[[1]]+img[[3]], xydim = xydim)[,,1]);
cc=fucci_[paste0(FoF,"_cell",coord_$id),"cellCycle"]
points(coord_$x,coord_$y,col=scales::alpha(fuccicol[cc], 0.005),main=paste(FoF,"fucci"),xaxt='n',yaxt='n', ann=FALSE)
## jordan: contour
legend("bottomleft", names(fuccicol) , fill=fuccicol)
dev.off()

la=png::readPNG(figname,native = F)
plot(NA, xlim = c(0, ncol(la)/nrow(la)), ylim = c(0, 1), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "")
rasterImage(la, 0, 0, ncol(la)/nrow(la),1)
```



Figure 1C: Fucci based pseudotime inference reveals cell cycle progression
```{r}
figname = paste0(OUTFIGS, filesep,"Fig1C_",thedate,".png")

png(figname )
bioimagetools::img(img[[2]][,,1]);
fucci_[,"pseudotimeCol"]=round(fucci_[,"pseudotime"]*10)
col=fliplr(heat.colors(max(fucci_[,"pseudotimeCol"])))
## jordan: color code intuitive match to panel B
cc=fucci_[paste0(FoF,"_cell",coord_$id),"pseudotimeCol"]
points(coord_$x,coord_$y,col=scales::alpha(col[cc], 0.005),xaxt='n',yaxt='n', ann=FALSE,main=paste(FoF,"fucci pseudotime"))
## jordan: add color bar as legend
dev.off()

la=png::readPNG(figname,native = F)
plot(NA, xlim = c(0, ncol(la)/nrow(la)), ylim = c(0, 1), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "")
rasterImage(la, 0, 0, ncol(la)/nrow(la),1)

```



Figure 1D: Fucci based pseudotime trajectory in PCA space. 
```{r}
tmp=plot_dimred(model[[paste0("Fucci_",FoF)]],color_cells = "pseudotime")
tmp
## Jordan: color code should be same as previous panel
# ggsave(paste0(OUTFIGS,"Fig1D_Fucci_",FoF,"_pseudotimeTSNE_",thedate,".png"), plot=tmp)
```



Figure 1E + supplementary Fig: Pseudotime is differentially distributed across the four descrete cell cycle classes. 
```{r}
# pdf(paste0(OUTFIGS, filesep,"Fig1E_plusSIFig_",thedate,".pdf") )
par(mfrow=c(2,3))
ii = sapply(FoFs[c(1,2,4,3)], function(x) grep(x,names(model$Fucci_All$pseudotime),value=T))
sapply(names(ii), function(x) boxplot(model$Fucci_All$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="fucci pseudotime", main=x,cex.main=0.6, cex.axis=0.6))
boxplot(model$Fucci_All$pseudotime[rownames(fucci_raw)]~fucci_raw[,"cellCycle"], xlab="", names=names(fuccicol), ylab="fucci pseudotime", main="All",cex.main=0.6, cex.axis=0.6)
# dev.off()
```




Figure 2: Quantification of nuclei, mitochondria and cytoplasm features at single-cell resolution with label free imaging. Setup first:
```{r}
coord_=readOrganelleCoordinates(signals_per_id[[FoF]], names(signals), OUTLINKED_)
imgStats_=imgStats[imgStats$FoF==FoF,]
doplotcentercoord=c(200, 200)
ii=which(coord_$signal=="nucleus.p")
centroids=grpstats(coord_[ii,c("x","y","z","id")], g = coord_$id[ii],statscols = "median")$median
o2=flexclust::dist2(centroids[,c("x","y")],doplotcentercoord)
alpha=list(cytoplasm.p=0.035,cytoplasm.t=0.01,nucleus.t=1,nucleus.p=0.135,mito.t=0.035,mito.p=0.035)
```



Figure 2A: Predicted nuclei, mitochondria and cytoplasm signals. 
```{r}
# jordan: 3 channel overlay, should be in A03_AllenModel

```


Figure 2B: Nuclei, mitochondria and cytoplasm of 10 representative cells from region highlighed in (A). Every data point is color-coded according to its cell membership. 
```{r}
figname=paste0(OUTFIGS, filesep, "Fig2B_2024-05-16_100.png")

if(!file.exists(figname)){
  NCELLS=10
  coi=rownames(centroids)[order(o2)[1:NCELLS]]
  coi=setdiff(coi, rownames(imgStats_)[imgStats_$segmentationError])
  coord__=coord_[coord_$id %in% coi,]
  zlim=getZLIM(coord__)
  rgl::close3d()
  col=rainbow(length(unique(coord__$id)))
  names(col)=as.character(unique(coord__$id))
  for(s in names(signals)){
    X=coord__[coord__$signal==s,]
    if(s=="nucleus.p"){
      rgl::plot3d(X$x, X$y, X$z, pch3d=20, zlim=zlim, size=2, axes=F, xlab="",ylab="", zlab="",col=col[as.character(X$id)],alpha=alpha[[s]]*4, add=T)
    }else{
      rgl::points3d(X$x, X$y, X$z, pch3d=20, col=col[as.character(X$id)],alpha=alpha[[s]]*4, add=T)
    }
  }
  
  rgl::movie3d( movie=fileparts(figname)$name, rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  duration = 3,  dir = OUTFIGS,  type = "gif", clean = TRUE)
}

## For display in rmd only:
la=png::readPNG(figname,native = F)
plot(NA, xlim = c(0, ncol(la)/nrow(la)), ylim = c(0, 1), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "")
rasterImage(la, 0, 0, ncol(la)/nrow(la),1)
```



Figure 2C: Nuclei, mitochondria and cytoplasm of 1 representative cell from (B). Every data point is color-coded according to its organelle class. 
```{r}
figname=paste0(OUTFIGS, filesep, "Fig2C_2024-05-16_3.png")

if(!file.exists(figname)){
  coi=rownames(centroids)[order(o2)[7]]
  coi=setdiff(coi, rownames(imgStats_)[imgStats_$segmentationError])
  coord__=coord_[coord_$id %in% coi,]
  zlim=getZLIM(coord__)
  col=rainbow(length(unique(coord__$signal))*1.3)
  names(col)=as.character(unique(coord__$signal))
  rgl::close3d()
  for(s in names(signals)){
    X=coord__[coord__$signal==s,]
    if(s=="nucleus.p"){
      rgl::plot3d(X$x, X$y, X$z, pch3d=20, zlim=zlim, size=2, axes=F, xlab="",ylab="", zlab="",col=col[X$signal],alpha=4*alpha[[s]], add=T)
    }else{
      rgl::points3d(X$x, X$y, X$z, pch3d=20, col=col[X$signal],alpha=alpha[[s]]*4, add=T)
    }
  }
  rgl::legend3d("bottomright",names(signals),fill=col[names(signals)])
  rgl::movie3d( movie=paste0("Fig2C_",thedate), rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  duration = 1,  dir = OUTFIGS,  type = "gif", clean = TRUE)
}

## For display in rmd only:
la=png::readPNG(figname,native = F)
plot(NA, xlim = c(0, ncol(la)/nrow(la)), ylim = c(0, 1), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "")
rasterImage(la, 0, 0, ncol(la)/nrow(la),1)
```



Figure 2D: Cell features quantified from label free imaging correlate with cell cycle classes as defined by FUCCI. 
```{r}
# pdf(paste0(OUTFIGS, filesep,"Fig2D_",thedate,".pdf"), width = 10, height = 5 )
par(mfrow=c(2,6))
for(x in svm$svmFeatures){
  boxplot(imgStats[,x]~fucci_raw[rownames(imgStats),"cellCycle"],ylab=x,xlab="", names=names(fuccicol),cex.axis=0.6,cex.main=0.6, las=2)
  # Jordan: split and color code boxes by FoF 
}
# dev.off()
```


Figure 3: Characterization of discrete and continuous cell cycle progression in NCI-N87 with label free imaging. 
Figure 3A: Supervised approach to predict discrete cell cycle state from nuclei, mitochondria and cytoplasm features. 
```{r}
## Make diagram in pptx showing:
print(paste("Total cells:",nrow(imgStats),"split into:"), quote = F)
print(paste("Training:",length(unlist(svm$training)),"cells"), quote = F)
print(paste("Testing:",length(unlist(svm$testing)),"cells"), quote = F)
print(paste("SVM trained on",length(svm$svmFeatures),"features and applied on test set"))
```


Figure 3B: Performance of trained classifier on test set. 
```{r}
confMat = read.xlsx(paste0(OUTPSEUDOTIME, filesep,"cellCyclePrediction_svm_2024-05-15.xlsx"), sheetIndex = 1, row.names=T)
tmp=sapply(c("Class..1","Class..2","Class..3","Class..4"), function(x) as.numeric(confMat[grep(x, rownames(confMat)),"Balanced.Accuracy"])) 
# pdf(paste0(OUTFIGS, filesep,"Fig3B_",thedate,".pdf") )
boxplot(tmp, names=names(fuccicol), ylab="Balanced.Accuracy")
# dev.off()
```


Figure 3C: Unsupervised approach to predict continuous cell cycle progression from nuclei, mitochondria and cytoplasm features. . 
```{r}
tmp=plot_dimred(model[[FoF]],color_cells = "pseudotime")
tmp
#ggsave(paste0(OUTFIGS,"Fig3C_labelFree_",FoF,"_pseudotimeTSNE_",thedate,".png"), plot=tmp)

```


Figure 3D + supplementary Fig: Pseudotime derived from label free imaging features is differentially distributed across the four FUCCI-informed cell cycle classes.  
```{r}
# pdf(paste0(OUTFIGS, filesep,"Fig3D_plusSIFig_",thedate,".pdf") )
par(mfrow=c(2,3))
ii = sapply(FoFs[c(1,2,4,3)], function(x) grep(x,rownames(fucci_raw),value=T))
# sapply(names(ii), function(x) boxplot(model[[x]]$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main=x,cex.main=0.6))
sapply(names(ii), function(x) boxplot(model$All$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main=x, cex.axis=0.6,cex.main=0.6))
par(mfrow=c(1,2))
boxplot(model$All$pseudotime[rownames(fucci_raw)]~fucci_raw[,"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main="All",cex.main=0.6, cex.axis=0.6)
ii=names(model$All$pseudotime)
ii=grep(FoFs[1], ii, value=T, invert = T)
te=cor.test(model$All$pseudotime[ii], model$Fucci_All$pseudotime[ii])
col=rainbow(length(unique(fucci_raw[ii,"FoF"])))
names(col)=unique(fucci_raw[ii,"FoF"])
plot(model$All$pseudotime[ii], model$Fucci_All$pseudotime[ii], main=paste("r=",round(te$estimate,2),"P=",te$p.value), xlab="label free pseudotime",  ylab="fucci pseudotime",  col=col[fucci_raw[ii,"FoF"]])
legend("bottomleft",sapply(strsplit(names(col),"_"),"[[",1),fill=col)
# dev.off()
```


Figure 3E: representative cell across cell cycle: fucci. 
```{r}
# jordan: sample cells from 5+ timepoints (from fucci pseudotime) and visualize each with Fucci channels
```


Figure 3F: representative cell across cell cycle: label free. 
```{r}
# jordan: sample cells from 5+ timepoints (from pseudotime in Fig. 3C) and visualize each as in panel 2C
```




Figure 4: Sequencing imaging integration

Figure 4A: Sequencing derived pseudotime of cell cycle progression
```{r}

plot_dimred(model$Seq,color_cells = "pseudotime")
```

Figure 4B: Co-clustering of sequenced and imaged cells based on pseudotime
```{r}
## co-cluster image and sequencing stats
load(paste0(OUTPSEUDOTIME, filesep,"scRNAdataset_2024-05-15.RObj")); ## loads pq
tmp=as.data.frame(model$All$pseudotime)
colnames(tmp)="pseudotime"
tmp$FoF=imgStats[rownames(tmp),]$FoF
stats=rbind(pq[,c("pseudotime","FoF")],tmp)
rownames(stats) = paste0(rownames(stats), "_seq")
ii=which(stats$FoF %in% FoFs)
rownames(stats)[ii]=gsub("_seq$", "_img",rownames(stats)[ii])
dd = as.matrix(dist(stats[,grep("pseudotime",colnames(stats))]))
rownames(dd)<-colnames(dd)<-rownames(stats)
tr = ape::nj(dd)
col = rep("red", length(tr$tip.label))
col[grep("img",tr$tip.label) ] = "blue"
par(mfrow=c(1,1))
plot(tr,show.tip.label = T, tip.color = col, cex=0.36)
legend("topright",c("sequenced cell","imaged cell"),fill=c("red","blue"),cex=1.8)
## jordan: prettify :)
```

Figure 4C: Correlation between gene expression and imaging-derived features
```{r}
##for each img cell which seqed cells have this cell as nearest pseudotime neighbor?
dd = dist2(pq[,"pseudotime",drop=F], as.matrix(model$All$pseudotime)) 
rownames(dd)=rownames(pq)
colnames(dd)=rownames(imgStats)
imgCells=colnames(dd)[apply(dd,1,which.min)]
nearest_seqCells=list()
for(imgcell in unique(imgCells)){
  nearest_seqCells[[imgcell]]=rownames(dd)[which(imgcell==imgCells)]
}

## correlation btw gene expression and img features
cc <- pval <- list()
pairs=list()
toExclude=c("FoF","frame","ID","count_nucleus.p","png","pseudotime","segmentationError","smv_cell","smv_nucleus.p","smv_mito.p","smv_cytoplasm.p",xyz[1:2]);
for(sFeature in setdiff(colnames(pq),toExclude)){
  s = sapply(nearest_seqCells, function(x) mean(pq[x,sFeature]))
  names(s) = names(nearest_seqCells)
  pairs[[sFeature]] = list()
  for(iFeature in setdiff(colnames(imgStats), toExclude)){
    x=cor.test(s, imgStats[names(s),iFeature])
    pair=paste(sFeature, iFeature, sep = "+")
    cc[[sFeature]][[iFeature]] =x$estimate
    pval[[sFeature]][[iFeature]] =x$p.value
    pairs[[pair]] = list(s=s,i=imgStats[names(s),iFeature])
  }
}
cc=do.call(rbind,cc)
pval=do.call(rbind,pval)
tmp=rownames(cc)
cc = apply(cc,2,as.numeric)
pval = apply(pval,2,as.numeric)
rownames(cc) <- rownames(pval) <- tmp


## sort and plot
poi=unique(unlist(apply(abs(cc),2, function(x) which(x>0.5)), use.names = F))
cc=cc[,!apply(is.na(cc[poi,]),2,all)]
pval=pval[, colnames(cc)]
heatmap.2(t(cc[poi,]),trace="n", margins = c(10,10), cexCol = 0.68)
## jordan: prettify :)
# print(cc[p.adjust(pval, method = "fdr")<0.05])
MINCC=sort(abs(cc), decreasing = T)[9]
ii=which(abs(cc)>MINCC, arr.ind = T)
ii=apply(ii,1, function(x) c(rownames(cc)[x[1]],colnames(cc)[x[2]]))
colnames(ii)=apply(ii,2, paste, collapse="+")
par(mfrow=c(3,3))
sapply(colnames(ii), function(x) plot(pairs[[x]]$s, pairs[[x]]$i, main=x, cex.main=0.65, xlab=ii[1,x], ylab=ii[2,x]))
## jordan: prettify :)
```


Figure 5: Allen model training
```{r}

```

