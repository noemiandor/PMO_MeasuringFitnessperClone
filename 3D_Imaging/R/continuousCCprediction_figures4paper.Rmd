---
title: "Figures for paper"
date: "2024-05-16"
output: html_document
---

```{r setup, include=FALSE}
# knitr::opts_knit$set(root.dir = "~/Projects/PMO/MeasuringFitnessPerClone/code/3D_Imaging/R/data4paper")
knitr::opts_knit$set(root.dir = "C:/Users/80027908/Desktop/CC_project/PMO_MeasuringFitnessperClone-master/3D_Imaging/R/data4paper")
library(xlsx)
library(dyno)
library(gplots)
library(caret)
library(tidyverse)
library(matlab)
library(RColorBrewer)
library(flexclust)
library(ggplot2)
library(e1071)
library(slingshot)
library(umap)
library(patchwork)
# devtools::source_url("https://github.com/noemiandor/Utils/master/grpstats.R?raw=TRUE")
OUTLINKED="A06_multiSignals_Linked"
OUTPSEUDOTIME="A08_Pseudotime"
OUTSTATS="A07_LinkedSignals_Stats"
RAWDATA="A01_rawData"

OUTFIGS = "../figs4paper"

xydim = 255
pixelsize_xy = 0.232 # um 
z_interval = 0.29 #  um 
xyz=c("x","y","z")
zslice=35


grpstats <- function(x,g,statscols,q1=0.5){
  allOut=list()
  o=matrix(NA, length(unique(g)),ncol(x) )
  rownames(o)=unique(g); colnames(o)=colnames(x);
  for(col in statscols){
    for(m in unique(g)){
      ii=which(g==m);
      v=NA;
      if(col=='mean'){
        v=apply(x[ii,,drop=F],2,mean,na.rm=T)
      }else if(col=='sum'){
        v=apply(x[ii,,drop=F],2,sum,na.rm=T)
      }else if(col=='var'){
        v=apply(x[ii,,drop=F],2,var)
      }else if(col=='max'){
        v=apply(x[ii,,drop=F],2,max,na.rm=T)
      }else if(col=='min'){
        v=apply(x[ii,,drop=F],2,min,na.rm=T)
      }else if(col=='quantile'){
        v=apply(x[ii,,drop=F],2,quantile,q1,na.rm=T)
      }else if(col=='median'){
        v=apply(x[ii,,drop=F],2,median,na.rm=T)
      }else if(col=='numel+'){##Count elements >0 
        v=apply(x[ii,,drop=F]>0,2,sum,na.rm=T)
      }else if(col=='numel_u'){##Count unique elements 
        v=apply(x[ii,,drop=F],2, function(k) length(unique(k)))
      }else if(col=='fraction+'){##Fraction of elements> 0 out of all finite elements
        v1=apply(!is.na(x[ii,,drop=F]),2,sum,na.rm=T)
        v=apply(x[ii,,drop=F]>0,2,sum,na.rm=T)/v1
      }else if(col=='maxcount'){##Most frequent value
        v1=plyr::count(x[ii])
        v=v1$x[which.max(v1$freq)]
      }else{
        v=get(col)(x[ii,,drop=F])
      }
      o[as.character(m),]=v;
    }
    allOut[[col]]=o;
  }
  return(allOut)
}
```

Define local functions and read image coordinates and features used in multiple Figures:
```{r}
plotPNGorTIF<-function(figname){
  if(fileparts(figname)$ext!=".png"){
    la=tiff::readTIFF(figname)
  }else{
    la=png::readPNG(figname,native = F)
  }
  plot(NA, xlim = c(0, ncol(la)/nrow(la)), ylim = c(0, 1), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "")
  rasterImage(la, 0, 0, ncol(la)/nrow(la),1)
  return(la)
}


getZLIM<- function(coord__){
  tmp = quantile(coord__$z,c(0,1))
  space=tmp[2]-tmp[1]
  zlim=c(tmp[1]-space/2, tmp[2]+space/2)
  return(zlim)
}

readOrganelleCoordinates<-function(signals_per_id, signals, IN){
  coord=NULL;
  for(cell in signals_per_id$x){
    for(s in signals){
      x=paste0(s,"_cell_",cell,"_coordinates.csv")
      a=read.csv(paste0(IN,filesep,x))
      ## pixel to um conversion: @TODO
      a$z=a$z*z_interval
      a$x=a$x*pixelsize_xy
      a$y=a$y*pixelsize_xy
      # id=strsplit(fileparts(x)$name,"_")[[1]]
      a$organelle = a[,ncol(a)] 
      a$intensity = a$signal
      a$signal=s
      # id=id[length(id)-1]
      a$id=cell
      ## add missing columns
      if(!is.null(coord)){
        for(mc in setdiff(colnames(a), colnames(coord))){
          coord[,mc]=NA
        }
        tmp=matrix(NA,nrow(a), ncol(coord))
        colnames(tmp) = colnames(coord)
        coord=rbind(tmp, coord)
        coord[1:nrow(a),colnames(a)] = a
      }else{
        coord=a
      }
      # a[,c("y", "x", "z", "organelle", "id","signal")]
    }
  }
  coord$id=as.numeric(coord$id)
  return(coord)
}

FoFs=c("FoF1_231005_fluorescent.nucleus", "FoF2_231005_fluorescent.nucleus", "FoF3_231005_fluorescent.nucleus", "FoF4_231005_fluorescent.nucleus")

signals=list(nucleus.p="nucleus.p_Cells_Centers.csv",mito.p="mito.p_Cells_Centers.csv",cytoplasm.p="cytoplasm.p_Cells_Centers.csv")
signals_per_id=list()
for(FoF in FoFs){
  OUTLINKED_=paste0(OUTLINKED,filesep,FoF,filesep)
  f=list.files(OUTLINKED_,full.names = T, pattern = ".csv")
  signals_per_id[[FoF]]=plyr::count(sapply(strsplit(f,"_"), function(x) x[length(x)-1]))
}

thedate=strsplit(as.character(Sys.time())," ")[[1]][1]
FoF=FoFs[3]
OUTLINKED_=paste0(OUTLINKED,filesep,FoF,filesep)

load(paste0(OUTPSEUDOTIME, filesep,"pseudotime_2024-05-15.RObj")) ## loads unsupervised pseudotime *model* list
load(paste0(OUTPSEUDOTIME, filesep,"cellCyclePredictionFromImgFeatures_svm_2024-05-15.RObj"))  ## load *svm* details

fucci_raw=read.table( paste0(OUTPSEUDOTIME,filesep,"Fucci_stats.txt"),sep="\t", header = T)
imgStats = read.table(paste0(OUTPSEUDOTIME,filesep,"LabelFree_stats.txt"),sep="\t",header = T)
```



Figure 1: FUCCI to characterize discrete and continuous cell cycle progression in NCI-N87. Setup first:

```{r}
fuccicol=fliplr(rainbow(max(fucci_raw$cellCycle)*1.2)[1:max(fucci_raw$cellCycle)])
names(fuccicol) = c("G1", "G1/S transition","S","G2/M")
fucci_=fucci_raw[fucci_raw$FoF==FoF,]
coord_=readOrganelleCoordinates(signals_per_id[[FoF]], "nucleus.p", OUTLINKED_)
coord_[,c("x","y")] = coord_[,c("x","y")]/pixelsize_xy
coord_ = coord_[coord_$z == zslice*z_interval, ]
coord_$x=-coord_$x
coord_$x=-max(coord_$x)+coord_$x-min(coord_$x)
coord_1 <- coord_
TIF=list.files(paste0(RAWDATA,filesep,FoF), pattern=paste0("_z",zslice), full.names = T)
img=sapply(TIF, function(x) bioimagetools::readTIF(x), simplify = F)
img=sapply(img, function(x) EBImage::rotate(x,-180), simplify = F)
```

Figure 1A: Green and red Fucci channels overlaid. 
```{r}
## Jordan - overlay green [[1]] and red [[3]] - done

# figname = paste0(OUTFIGS, filesep, "Fig1A_1_",thedate,".png") 
# png(figname)
# bioimagetools::img(img[[1]][,,1]);
# dev.off()
# 
# figname = paste0(OUTFIGS, filesep, "Fig1A_3_",thedate,".png") 
# png(figname)
# bioimagetools::img(img[[3]][,,1]);
# dev.off()

## ImageJ macro for edits
# open("Fig1A_1_2024-05-21.png")
# run("Auto Crop");
# run("Green");
# run("RGB Color");
# open("Fig1A_3_2024-05-21.png")
# run("Auto Crop");
# run("Red");
# run("RGB Color");
# imageCalculator("Add create", "Fig1A_1_2024-05-21.png","Fig1A_3_2024-05-21.png");
# selectImage("Result of Fig1A_1_2024-05-21.png");
# saveAs("Tiff", "Fig1A_overlay.tif");

figname = paste0(OUTFIGS, filesep, "Fig1A_",thedate,".png")
png(figname)
im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"Fig1A_overlay.tif"))
im <- EBImage::resize(im, dim(im)[1]/1)
plot(raster::as.raster(im[,,,1]))
dev.off()

la=plotPNGorTIF(figname)

```



Figure 1B,G: Fucci based descrete cell cycle classification. 
```{r}
library(viridis)
palette(c("#FDE725FF", "#35B779FF", "#31688E", "#440154"))

figname = paste0(OUTFIGS, filesep, "Fig1G_",thedate,".png")
png(figname)
plot(fucci_raw$Intensity_IntegratedIntensity_green, fucci_raw$Intensity_IntegratedIntensity_red, col=fucci_raw$cellCycle, pch=20, log="xy")
legend("bottomright", names(fuccicol), fill=1:4)
dev.off()

la=plotPNGorTIF(figname)
fr = plyr::count(names(fuccicol)[fucci_raw$cellCycle])
fr$pct = fr$freq/sum(fr$freq)
print(fr)

## Create two input images for loading into imagej
# cc <-  fucci_ %>% 
#   select(ID, cellCycle)
# coord_ <- left_join(coord_, cc, by = join_by(id == ID))
# 
# pal = colorRampPalette(c("#FDE725FF", "#35B779FF", "#31688E", "#440154"))
# figname = paste0(OUTFIGS, filesep,"overlay.png") 
# png(figname)
# im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"black_blank.tif"))
# im <- EBImage::resize(im, dim(im)[1]/1)
# plot(raster::as.raster(im[,,,1]))
# # points(coord_$x,coord_$y,col=coord_$cellCycle,main=paste(FoF,"fucci"),xaxt='n',yaxt='n', ann=FALSE)
# points(coord_$x,coord_$y,col=scales::alpha(pal(4)[coord_$cellCycle], 0.02),main=paste(FoF,"fucci"),xaxt='n',yaxt='n', ann=FALSE)
# dev.off()
# 
# figname = paste0(OUTFIGS, filesep,"image.png") 
# png(figname)
# bioimagetools::img(img[[2]][,,1]);
# legend("bottomleft", names(fuccicol) , fill=c("#FDE725FF", "#35B779FF", "#31688E", "#440154"))
# dev.off()

## Imagej macro for edits; direct from recorder
# open("C:/Users/80027908/Desktop/CC_project/image.png");
# open("C:/Users/80027908/Desktop/CC_project/overlay.png");
## For threshold, pass all colors and take all but the brightest and darkest intensities
# run("Color Threshold...");
# run("Make Inverse");
# setForegroundColor(0, 0, 0);
## For fill, make sure you fill with black
# run("Fill", "slice");
# selectImage("overlay_2024-05-19.png");
# run("Select None");
## Again fill with black
# //setTool("rectangle");
# makeRectangle(68, 352, 32, 33);
# run("Fill", "slice");
# makeRectangle(77, 111, 4, 18);
# run("Fill", "slice");
# selectImage("image.png");
# run("Add Image...", "image=overlay.png x=0 y=0 opacity=60 zero");
# run("Flatten");
# saveAs("Tiff", "C:/Users/80027908/Desktop/CC_project/Fig1B_contour.tif");

figname = paste0(OUTFIGS, filesep, "Fig1B_",thedate,".png")
png(figname)
im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"Fig1B_contour.tif"))
im <- EBImage::resize(im, dim(im)[1]/1)
plot(raster::as.raster(im[,,,1]))
dev.off()

la=plotPNGorTIF(figname)
```



Figure 1C: Fucci based pseudotime inference reveals cell cycle progression
```{r}
## Jordan - continuous scale - done

cc <-  fucci_ %>% 
  select(ID, pseudotime)
coord_a <- left_join(coord_, cc, by = join_by(id == ID))
coord_a$order <- findInterval(coord_a$pseudotime, sort(coord_a$pseudotime))

# Create legend image -> manually crop borders before producing the next graph
# pal = colorRampPalette(c("#440154FF", "#31688EFF", "#35B779FF", "#FDE725FF"))
# png(paste0(OUTFIGS, filesep, "legend.png"), width = 250, height = 300)
# plot.new()
# lgd_ = rep(NA, 9)
# lgd_[c(1,5,9)] = c("G2/M", "S", "G1")
# legend(x = 0, y = 1.02,
#        legend = lgd_,
#        fill = pal(9),
#        border = NA,
#        y.intersp = 0.5,
#        bty = "n",
#        cex = 2, text.font = 4)
# dev.off()

pal = colorRampPalette(c("#440154", "#31688E", "#35B779FF", "#FDE725FF"))
figname = paste0(OUTFIGS, filesep,"Fig1C_",thedate,".png")
png(figname)
bioimagetools::img(img[[2]][,,1]);
fucci_[,"pseudotimeCol"]=round(fucci_[,"pseudotime"]*10)
points(coord_a$x,coord_a$y,col=scales::alpha(pal(nrow(coord_a))[coord_a$order], 0.03),xaxt='n',yaxt='n', ann=FALSE,main=paste(FoF,"fucci pseudotime"))
legend <- png::readPNG(paste0(OUTFIGS, filesep, "legend.png"))
rasterImage(legend,850,600,1000,850)
dev.off()

la=plotPNGorTIF(figname)
```



Figure 1D: Fucci based pseudotime trajectory in PCA space. 
```{r}
## Jordan - color code matches - Yes, I believe (low pseudotime = "high" cellCyle)
tmp=plot_dimred(model[[paste0("Fucci_",FoF)]],color_cells = "pseudotime", size_cells=0.4,size_milestones=0.4)
tmp
ggsave(paste0(OUTFIGS,filesep,"Fig1D_",thedate,"_Fucci_",FoF,"_pseudotimeTSNE.png"),units="px",width = 0.6*480, height = 480, plot=tmp)
```



Figure 1E + supplementary Fig: Pseudotime is differentially distributed across the four discrete cell cycle classes. 
```{r}
figname = paste0(OUTFIGS, filesep,"Fig1E_",thedate,".png")
png( figname)
par(mfrow=c(2,3))
ii = sapply(FoFs[c(1,2,4,3)], function(x) grep(x,names(model$Fucci_All$pseudotime),value=T))
sapply(names(ii), function(x) boxplot(model$Fucci_All$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="fucci pseudotime", main=x,cex.main=0.6, cex.axis=0.6))
boxplot(model$Fucci_All$pseudotime[rownames(fucci_raw)]~fucci_raw[,"cellCycle"], xlab="", names=names(fuccicol), ylab="fucci pseudotime", main="All",cex.main=0.6, cex.axis=0.6)
dev.off()

la=plotPNGorTIF(figname)
```




Figure 2: Quantification of nuclei, mitochondria and cytoplasm features at single-cell resolution with label free imaging. Setup first:
```{r}
coord_=readOrganelleCoordinates(signals_per_id[[FoF]], names(signals), OUTLINKED_)
imgStats_=imgStats[imgStats$FoF==FoF,]
doplotcentercoord=c(200, 200)
ii=which(coord_$signal=="nucleus.p")
centroids=grpstats(coord_[ii,c("x","y","z","id")], g = coord_$id[ii],statscols = "median")$median
o2=flexclust::dist2(centroids[,c("x","y")],doplotcentercoord)
alpha=list(cytoplasm.p=0.035,cytoplasm.t=0.01,nucleus.t=1,nucleus.p=0.135,mito.t=0.035,mito.p=0.035)
```



Figure 2A: Predicted nuclei, mitochondria and cytoplasm signals. 
```{r}
## Jordan: Fig 2A: highlight in Figure which cells were used for panel 2B

## ImageJ macro for all channels image
# open("C:/Users/80027908/Downloads/cytoplasm.p.tif");
# run("Green Fire Blue");
# run("RGB Color");
# open("C:/Users/80027908/Downloads/nucleus.p.tif");
# run("Magenta Hot");
# run("RGB Color");
# open("C:/Users/80027908/Downloads/mito.p.tif");
# run("Red Hot");
# imageCalculator("Add create stack", "cytoplasm.p.tif","nucleus.p.tif");
# selectImage("Result of cytoplasm.p.tif");
# imageCalculator("Add create stack", "Result of cytoplasm.p.tif","mito.p.tif");
# selectImage("Result of Result of cytoplasm.p.tif");
# saveAs("Tiff", "C:/Users/80027908/Desktop/CC_project/Fig2A_stack.tif");
# run("Slice Keeper", "first=14 last=14 increment=1");
# saveAs("Tiff", "C:/Users/80027908/Desktop/CC_project/Fig2A_slice.tif");
# 
## ImageJ macro for brightfield and nuclear image
# open("C:/Users/80027908/Downloads/nucleus.p.tif");
# run("Cyan Hot");
# run("RGB Color");
# open("C:/Users/80027908/Downloads/0_signal.tif");
# run("RGB Color");
# imageCalculator("Add create stack", "0_signal.tif","nucleus.p.tif");
# selectImage("Result of 0_signal.tif");
# saveAs("Tiff", "C:/Users/80027908/Desktop/CC_project/Fig2Ab_stack.tif");
# run("Slice Keeper", "first=14 last=14 increment=1");
# saveAs("Tiff", "C:/Users/80027908/Desktop/CC_project/Fig2Ab_slice.tif");

## Create legend image -> manually crop borders before producing the next graph
# pal = colorRampPalette(c("magenta", "white", "yellow", "white", "cyan"))
# png(paste0(OUTFIGS, filesep, "legend_2.png"), width = 300, height = 250)
# plot.new()
# lgd_ = rep(NA, 5)
# lgd_[c(1,3,5)] = c("Nucleus", "Mitochondria", "Cytoplasm")
# legend(x = 0, y = 1.02,
#        legend = lgd_,
#        fill = pal(5),
#        border = NA,
#        y.intersp = 0.5,
#        bty = "n",
#        cex = 2, text.font = 0.2)
# dev.off()

figname = paste0(OUTFIGS, filesep, "Fig2A_",thedate,".png")
png(figname)
im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"Fig2A_slice.tif"))
im <- EBImage::resize(im, dim(im)[1]/1)
plot(raster::as.raster(im[,,,1]))
legend <- png::readPNG(paste0(OUTFIGS, filesep, "legend_2.png"))
rasterImage(legend,25,900,225,1000)
dev.off()

la=plotPNGorTIF(figname)

# Added this here in case you wanted the nuclear + brightfield at any point
figname = paste0(OUTFIGS, filesep, "Fig2Ab_",thedate,".png")
png(figname)
im <- bioimagetools::readTIF(paste0(OUTFIGS, filesep,"Fig2Ab_slice.tif"))
im <- EBImage::resize(im, dim(im)[1]/1)
plot(raster::as.raster(im[,,,1]))
dev.off()

la=plotPNGorTIF(figname)
```


Figure 2B: Nuclei, mitochondria and cytoplasm of 10 representative cells from region highlighted in (A). Every data point is color-coded according to its cell membership. 
```{r}
figname=paste0(OUTFIGS, filesep, "Fig2B_2024-05-16_100.png")

if(file.exists(figname)){
  NCELLS=10
  coi=rownames(centroids)[order(o2)[1:NCELLS]]
  coi=setdiff(coi, rownames(imgStats_)[imgStats_$segmentationError])
  coord__=coord_[coord_$id %in% coi,]
  assign("coord__", coord__, .GlobalEnv)
  zlim=getZLIM(coord__)
  rgl::close3d()
  col=rainbow(length(unique(coord__$id)))
  names(col)=as.character(unique(coord__$id))
  for(s in names(signals)){
    X=coord__[coord__$signal==s,]
    if(s=="nucleus.p"){
      rgl::plot3d(X$x, X$y, X$z, pch3d=20, zlim=zlim, size=2, axes=F, xlab="",ylab="", zlab="",col=col[as.character(X$id)],alpha=alpha[[s]]*4, add=T)
    }else{
      rgl::points3d(X$x, X$y, X$z, pch3d=20, col=col[as.character(X$id)],alpha=alpha[[s]]*4, add=T)
    }
  }
  
  rgl::movie3d( movie=fileparts(figname)$name, rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  duration = 3,  dir = OUTFIGS,  type = "gif", clean = TRUE)
}

## For display in rmd only:
la=plotPNGorTIF(figname)
```



Figure 2C: Nuclei, mitochondria and cytoplasm of 1 representative cell from (B). Every data point is color-coded according to its organelle class. 
```{r}
figname=paste0(OUTFIGS, filesep, "Fig2C_2024-05-16_3.png")

if(!file.exists(figname)){
  coi=rownames(centroids)[order(o2)[7]]
  coi=setdiff(coi, rownames(imgStats_)[imgStats_$segmentationError])
  coord__=coord_[coord_$id %in% coi,]
  zlim=getZLIM(coord__)
  col=rainbow(length(unique(coord__$signal))*1.3)
  names(col)=as.character(unique(coord__$signal))
  rgl::close3d()
  for(s in names(signals)){
    X=coord__[coord__$signal==s,]
    if(s=="nucleus.p"){
      rgl::plot3d(X$x, X$y, X$z, pch3d=20, zlim=zlim, size=2, axes=F, xlab="",ylab="", zlab="",col=col[X$signal],alpha=4*alpha[[s]], add=T)
    }else{
      rgl::points3d(X$x, X$y, X$z, pch3d=20, col=col[X$signal],alpha=alpha[[s]]*4, add=T)
    }
  }
  rgl::legend3d("bottomright",names(signals),fill=col[names(signals)])
  rgl::movie3d( movie=paste0("Fig2C_",thedate), rgl::spin3d( axis = c(1, 1, 1), rpm = 8),  duration = 1,  dir = OUTFIGS,  type = "gif", clean = TRUE)
}

## For display in rmd only:
la=plotPNGorTIF(figname)
```



Figure 2D: Cell features quantified from label free imaging correlate with cell cycle classes as defined by FUCCI. 
```{r}
## Jordan - color by FoF - Done

var_list <- svm$svmFeatures
cycle <- fucci_raw[rownames(imgStats),"cellCycle"]

imgStats_b <- imgStats %>% 
  rownames_to_column(var = "long_ID") %>% 
  cbind(cycle) %>% 
  select(c(long_ID, ID, FoF, cellCycle = cycle, var_list))


list_plots <- vector('list', length(var_list))
for (i in seq_along(list_plots)) {
  list_plots[[i]] <- ggplot(imgStats_b) +
    geom_boxplot(aes(as.character(cellCycle), .data[[var_list[i]]], fill = FoF)) + # , color = as.character(cellCycle))) +
    scale_fill_manual(values = c("FoF1_231005_fluorescent.nucleus" = "chartreuse", 
      "FoF2_231005_fluorescent.nucleus" = "cadetblue2",
      "FoF3_231005_fluorescent.nucleus" = "gold",
      "FoF4_231005_fluorescent.nucleus" = "violetred1")) +
   # scale_color_manual(values = c("1" = "#FDE725FF", 
    #                              "2" = "#35B779FF", 
     #                             "3" = "#31688EFF", 
      #                            "4" = "#440154FF")) +
    theme_light() +
    theme(axis.title.x=element_blank(), legend.position = "none") +
    scale_x_discrete(labels=c("1" = "G1", "2" = "G1/S", "3" = "S", "4" = "G2"))
}

e <- ggplot() +
  theme_void()

a <- (list_plots[[1]] + list_plots[[2]] + list_plots[[3]])
b <- (list_plots[[4]] + list_plots[[5]] + list_plots[[6]])
c <- (list_plots[[7]] + list_plots[[8]] + list_plots[[9]])
d <- (list_plots[[10]] + list_plots[[11]] + e)

a/b/c/d
figname <- paste0(OUTFIGS, filesep, "Fig2D_",thedate,".png")
ggsave(figname, width = 15, height = 12)
la=plotPNGorTIF(figname)
dev.off()

# figname=paste0(OUTFIGS, filesep, "Fig2D_fill+color.png")
# la=plotPNGorTIF(figname)
```


Figure 3: Characterization of discrete and continuous cell cycle progression in NCI-N87 with label free imaging. 
Figure 3A: Supervised approach to predict discrete cell cycle state from nuclei, mitochondria and cytoplasm features. 
```{r}
## Make diagram in pptx showing:
print(paste("Total cells:",nrow(imgStats),"split into:"), quote = F)
print(paste("Training:",length(unlist(svm$training)),"cells"), quote = F)
print(paste("Testing:",length(unlist(svm$testing)),"cells"), quote = F)
print(paste("SVM trained on",length(svm$svmFeatures),"features and applied on test set"))
```


Figure 3B: Performance of trained classifier on test set. 
```{r}
confMat = read.xlsx(paste0(OUTPSEUDOTIME, filesep,"cellCyclePrediction_svm_2024-05-15.xlsx"), sheetIndex = 1, row.names=T)
tmp=sapply(c("Class..1","Class..2","Class..3","Class..4"), function(x) as.numeric(confMat[grep(x, rownames(confMat)),"Balanced.Accuracy"])) 

figname=paste0(OUTFIGS, filesep,"Fig3B_",thedate,".png")
png(figname )
boxplot(tmp, names=names(fuccicol), ylab="Balanced.Accuracy")
dev.off()

la=plotPNGorTIF(figname)
```


Figure 3C: Unsupervised approach to predict continuous cell cycle progression from nuclei, mitochondria and cytoplasm features. . 
```{r}
tmp=plot_dimred(model[[FoF]],color_cells = "pseudotime", size_cells=0.4,size_milestones=0.4)
tmp
ggsave(paste0(OUTFIGS,filesep,"Fig3C_",thedate,"_labelFree_",FoF,"_pseudotimeTSNE.png"),units="px",width = 0.6*480, height = 480, plot=tmp)
```


Figure 3D + supplementary Fig: Pseudotime derived from label free imaging features is differentially distributed across the four FUCCI-informed cell cycle classes.  
```{r}
figname=paste0(OUTFIGS, filesep,"Fig3D_",thedate,"_plusSIFig.png")
png(figname )
par(mfrow=c(2,3))
ii = sapply(FoFs[c(1,2,4,3)], function(x) grep(x,rownames(fucci_raw),value=T))
# sapply(names(ii), function(x) boxplot(model[[x]]$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main=x,cex.main=0.6))
sapply(names(ii), function(x) boxplot(model$All$pseudotime[ii[[x]]]~fucci_raw[ii[[x]],"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main=x, cex.axis=0.6,cex.main=0.6))
dev.off()
la=plotPNGorTIF(figname)

figname=paste0(OUTFIGS, filesep,"Fig3D_",thedate,".png")
png(figname )
par(mfrow=c(1,2))
boxplot(model$All$pseudotime[rownames(fucci_raw)]~fucci_raw[,"cellCycle"], xlab="", names=names(fuccicol), ylab="label free pseudotime", main="All",cex.main=0.6, cex.axis=0.6)
ii=names(model$All$pseudotime)
ii=grep(FoFs[1], ii, value=T, invert = T)
te=cor.test(model$All$pseudotime[ii], model$Fucci_All$pseudotime[ii])
col=rainbow(length(unique(fucci_raw[ii,"FoF"])))
names(col)=unique(fucci_raw[ii,"FoF"])
plot(model$All$pseudotime[ii], model$Fucci_All$pseudotime[ii], main=paste("r=",round(te$estimate,2),"P=",te$p.value), xlab="label free pseudotime",  ylab="fucci pseudotime",  col=col[fucci_raw[ii,"FoF"]])
legend("bottomleft",sapply(strsplit(names(col),"_"),"[[",1),fill=col)
dev.off()
la=plotPNGorTIF(figname)
```


Figure 3E: representative cell across cell cycle: fucci. 
```{r}
# jordan: sample cells from 5+ timepoints (from fucci pseudotime) and visualize each with Fucci channels
=
tmp=plot_dimred(model[[paste0("Fucci_",FoF)]],color_cells = "pseudotime")
tmp

```


Figure 3F: representative cell across cell cycle: label free. 
```{r}
# jordan: sample cells from 5+ timepoints (from pseudotime in Fig. 3C) and visualize each as in panel 2C

cc <-  fucci_ %>%
  select(ID, cellCycle)
coord_a <- left_join(coord_1, cc, by = join_by(id == ID))

model_list <- model_df %>% 
  filter(abs(pseudotime-0)==min(abs(pseudotime-0)) | # cycle 2
           abs(pseudotime-0.3)==min(abs(pseudotime-0.3)) |
           abs(pseudotime-0.5)==min(abs(pseudotime-0.5)) | # cycle 4
           abs(pseudotime-0.7)==min(abs(pseudotime-0.7)) |
           abs(pseudotime-1)==min(abs(pseudotime-1))) %>%  # cycle 1
  separate(cell_ID, into = c(NA, NA, NA, "cell"), sep = "_")


cc <-  fucci_ %>%
  select(ID, cellCycle)
coord_b <- left_join(coord_a, cc, by = join_by(id == ID))

coord_b$cell <- paste0("cell", coord_b$id)

coord_c <- inner_join(coord_b, model_list, join_by(cell == cell)) 

ggplot(coord_) +
  geom_point(aes(x, y, color = as.character(cellCycle))) +
  scale_color_manual(values = c("1" = "#FDE725FF",
                                "2" = "#35B779FF",
                                "3" = "#31688EFF",
                                "4" = "#440154FF"))


tmp=plot_dimred(model[[FoF]],color_cells = "pseudotime")
tmp

```




Figure 4: Sequencing imaging integration

Figure 4A: Sequencing derived pseudotime of cell cycle progression
```{r}
# cell_ID <- model$Seq$cell_ids
# model_df <- cbind(pseudotime = model$Seq$pseudotime, cell_ID)

tmp=plot_dimred(model$Seq,color_cells = "pseudotime", size_cells=0.4,size_milestones=0.4)
tmp
ggsave(paste0(OUTFIGS,filesep,"Fig4A_",thedate,"_scRNA_pseudotimeTSNE.png"),  units="px",width = 0.6*480, height = 480, plot=tmp)
```


Figure 4B: Co-clustering of sequenced and imaged cells based on pseudotime
```{r}
## co-cluster image and sequencing stats
load(paste0(OUTPSEUDOTIME, filesep,"scRNAdataset_2024-05-15.RObj")); ## loads pq
tmp=as.data.frame(model$All$pseudotime)
colnames(tmp)="pseudotime"
tmp$FoF=imgStats[rownames(tmp),]$FoF
stats=rbind(pq[,c("pseudotime","FoF")],tmp)
rownames(stats) = paste0(rownames(stats), "_seq")
ii=which(stats$FoF %in% FoFs)
rownames(stats)[ii]=gsub("_seq$", "_img",rownames(stats)[ii])
dd = as.matrix(dist(stats[,grep("pseudotime",colnames(stats))]))
rownames(dd)<-colnames(dd)<-rownames(stats)
tr = ape::nj(dd)
col = rep("red", length(tr$tip.label))
col[grep("img",tr$tip.label) ] = "blue"

figname=paste0(OUTFIGS, filesep,"Fig4B_",thedate,".png") 
png(figname)
par(mfrow=c(1,1))
plot(tr,show.tip.label = T, tip.color = col, cex=0.36)
legend("topright",c("sequenced cell","imaged cell"),fill=c("red","blue"),cex=1.8)
## jordan: prettify :)
dev.off()

la=plotPNGorTIF(figname)
```

Figure 4C: Correlation between gene expression and imaging-derived features
```{r}
##for each img cell which seqed cells have this cell as nearest pseudotime neighbor?
dd = dist2(pq[,"pseudotime",drop=F], as.matrix(model$All$pseudotime)) 
rownames(dd)=rownames(pq)
colnames(dd)=rownames(imgStats)
imgCells=colnames(dd)[apply(dd,1,which.min)]
nearest_seqCells=list()
for(imgcell in unique(imgCells)){
  nearest_seqCells[[imgcell]]=rownames(dd)[which(imgcell==imgCells)]
}

## correlation btw gene expression and img features
cc <- pval <- list()
pairs=list()
toExclude=c("FoF","frame","ID","count_nucleus.p","png","pseudotime","segmentationError","smv_cell","smv_nucleus.p","smv_mito.p","smv_cytoplasm.p",xyz[1:2]);
for(sFeature in setdiff(colnames(pq),toExclude)){
  s = sapply(nearest_seqCells, function(x) mean(pq[x,sFeature]))
  names(s) = names(nearest_seqCells)
  pairs[[sFeature]] = list()
  for(iFeature in setdiff(colnames(imgStats), toExclude)){
    x=cor.test(s, imgStats[names(s),iFeature])
    pair=paste(sFeature, iFeature, sep = "+")
    cc[[sFeature]][[iFeature]] =x$estimate
    pval[[sFeature]][[iFeature]] =x$p.value
    pairs[[pair]] = list(s=s,i=imgStats[names(s),iFeature])
  }
}
cc=do.call(rbind,cc)
pval=do.call(rbind,pval)
tmp=rownames(cc)
cc = apply(cc,2,as.numeric)
pval = apply(pval,2,as.numeric)
rownames(cc) <- rownames(pval) <- tmp


## sort and plot
poi=unique(unlist(apply(abs(cc),2, function(x) which(x>0.5)), use.names = F))
cc=cc[,!apply(is.na(cc[poi,]),2,all)]
pval=pval[, colnames(cc)]
hm=heatmap.2(t(cc[poi,]),trace="n", margins = c(10,10), cexCol = 0.68)
eval(hm$call)
## jordan: prettify :)
# print(cc[p.adjust(pval, method = "fdr")<0.05])
MINCC=sort(abs(cc), decreasing = T)[9]
ii=which(abs(cc)>MINCC, arr.ind = T)
ii=apply(ii,1, function(x) c(rownames(cc)[x[1]],colnames(cc)[x[2]]))
colnames(ii)=apply(ii,2, paste, collapse="+")

figname=paste0(OUTFIGS, filesep,"Fig4C_",thedate,".png") 
png(figname)
eval(hm$call)
dev.off()

figname=paste0(OUTFIGS, filesep,"Fig4C_",thedate,"_plusSIFig.png") 
png(figname)
par(mfrow=c(3,3))
sapply(colnames(ii), function(x) plot(pairs[[x]]$s, pairs[[x]]$i, main=x, cex.main=0.65, xlab=ii[1,x], ylab=ii[2,x]))
dev.off()
## jordan: prettify :)

la=plotPNGorTIF(figname)
```


Figure 5: Allen model training
```{r}

```




Assemble panels to figure
```{r}
panels=list(Fig1=c("A","B","C","D","E"),Fig2=c("A","B","C","D"),Fig3=c("B","C","D"),Fig4=c("A","B","C"),Fig5=c("A","B","C","D","E"))
plots=list()
for(fig in names(panels)[1:4]){
  plots[[fig]]=list()
  for(panel in panels[[fig]]){
    f=list.files(OUTFIGS, pattern=paste0(fig,panel,"_2024"), full.names = T)
    f=grep(".pdf$",f, value = T, invert = T)
    f=grep(".gif$",f, value = T, invert = T)
    f=grep("_plusSI",f, value = T, invert = T)
    dates=sapply(f, function(x) strsplit(fileparts(x)$name,"_")[[1]][2])
    print(paste0(fig,panel))
    f=f[order(as.Date(dates),decreasing = T)[1]]
    # print(f)
    plots[[fig]][[panel]]=plotPNGorTIF(f)
  }
  print(sapply(plots[[fig]], dim))
}


```


Assemble panels to figure
```{r}
captions = list(Fig1="FUCCI to characterize discrete and continuous cell cycle progression in NCI-N87. 
A. Green and red Fucci channels overlayed. 
B,G: Fucci based discrete cell cycle classification. 
D: Fucci based pseudotime inference reveals cell cycle progression.
E: Fucci based pseudotime trajectory in PCA space. Every dot represents a cell. 
F: Pseudotime is differentially distributed across the four discrete cell cycle classes.", 

Fig2="Label-free quantification of nucleus, cytoplasm and mitochndria at single cell resolution.
A: Predicted nuclei, mitochondria and cytoplasm signals. 
B: Nuclei, mitochondria and cytoplasm of 10 representative cells from region highlighted in (A). Every data point is color-coded according to its cell membership. 
C: Nuclei, mitochondria and cytoplasm of 1 representative cell from (B). Every data point is color-coded according to its organelle class. 
D: Cell features quantified from label free imaging correlate with cell cycle classes as defined by FUCCI.",

Fig3="Characterization of discrete and continuous cell cycle progression in NCI-N87 with label free imaging. 
A: Supervised approach to predict discrete cell cycle state from nuclei, mitochondria and cytoplasm features. 
B: Performance of trained classifier on test set.
C: Unsupervised approach to predict continuous cell cycle progression from nuclei, mitochondria and cytoplasm features. 
D + supplementary Fig: Pseudotime derived from label free imaging features is differentially distributed across the four FUCCI-informed cell cycle classes.  
E: representative cell across cell cycle: fucci. 
F: representative cell across cell cycle: label free.",

Fig4="Sequencing imaging integration.
A: Sequencing derived pseudotime of cell cycle progression.
B: Co-clustering of sequenced and imaged cells based on pseudotime.
C: Correlation between pathway activity and imaging-derived features.", 

Fig5="Evaluating performance of a CNN to predict the spatial distribution of nuclei and mitochondria}. (A-C) Representative paired sets from model training using nucleus (train (N=37) / test (N=5) and mitochondria train (N=24) / test (N=5) models showing bright-field input, target signal and predicted signal (A), with train/validation rolling mean square error loss graphs for nucleus (B) and mitochondria (C). (D) Correlation coefficient of target fluorescence vs predicted fluorescence images paired with correlation coefficient from brightfield for the organelles that were used to train the models.")

thedate=strsplit(as.character(Sys.time())," ")[[1]][1]
BORDER=20
for(fig in names(plots)){
  # print(captions[[fig]])
  sz=fliplr(sapply(plots[[fig]], dim))
  # print(sz)
  ylim=sum(sz[2,])
  xlim=max(sz[1,])
  
  figname = paste0(OUTFIGS, filesep, fig,"_",thedate,".png")
  png(figname,width = xlim,height = ylim)
  plot(NA, xlim = c(0, xlim), ylim = c(0, ylim), type = "n", xaxt = "n", yaxt = "n", xlab = "", ylab = "")
  panel = fliplr(names(plots[[fig]]))[1]
  rasterImage(plots[[fig]][[panel]], 0, 0, sz[1,1],sz[2,1])
  for(i in 2:length(plots[[fig]])){
    panel = fliplr(names(plots[[fig]]))[i]
    sz[2,]=sz[2,]+BORDER
    sz[2,i]=sz[2,i-1]+sz[2,i]
    rasterImage(plots[[fig]][[panel]], 0, sz[2,i-1], sz[1,i],sz[2,i])
    # sz[2,]=sz[2,]+BORDER
    # sz[2,3]=sz[2,2]+sz[2,3]
    # rasterImage(plots[[fig]]$C, 0, sz[2,2], sz[1,3],sz[2,3])
    # sz[2,]=sz[2,]+BORDER
    # sz[2,4]=sz[2,3]+sz[2,4]
    # rasterImage(plots[[fig]]$B, 0, sz[2,3], sz[1,4],sz[2,4])
    # sz[2,]=sz[2,]+BORDER
    # sz[2,5]=sz[2,4]+sz[2,5]
    # rasterImage(plots[[fig]]$A, 0, sz[2,4], sz[1,5],sz[2,5])
    # Jordan: arrange in rows and columns instead of single row + add panels (A, B, C...)
  }
  dev.off()
  ## Print caption
  print(cat("\\begin{figure}\n",
              '\\includegraphics[width=\\textwidth,height=\\dimexpr \\textheight - 5\\baselineskip\\relax,keepaspectratio]{',gsub("../","",figname, fixed = T),"}\n",
              '\\caption{',captions[[fig]],".}\n",
              '\\label{',fig,"}\n",
              '\\end{figure}\n'))

}
```
